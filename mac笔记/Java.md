### Java 

#### 1、Java 中垃圾回收机制中如何判断对象需要回收？常见的 GC 回收算法有哪些？

参考：[JVM的垃圾回收机制 总结(垃圾收集、回收算法、垃圾回收器) - aspirant - 博客园 (cnblogs.com)](https://www.cnblogs.com/aspirant/p/8662690.html)



##### 1、判断对象是否可被回收

- 引用计数法
  - 给对象添加一个引用计数器，增加引用就+1，引用失效就-1，为0时对象可被回收
  - 存在循环引用的问题，java不使用这个
- 可达性分析算法
  - GC root 作为起始点进行搜索，能够到达的对象是存活的，不可达的就被回收
  - java使用这个作为判断，GC roots包含下面
    - 虚拟机栈中引用的对象
    - 本地方法栈中的对象
    - 方法区静态属性中的对象
    - 方法区常量引用的对象

##### 2、GC回收算法

> 标记-清除(Mark-Sweep)

标记阶段：标记所有需要被回收的对象

清楚阶段：回收被标记对象占用的空间

<img src="https://xy-picgo.oss-cn-shenzhen.aliyuncs.com/image-20240627172629518.png" alt="image-20240627172629518" style="zoom:50%;" />

问题：会产生内存碎片，碎片太多会导致大对象无法找到足够的空间

> 标记-复制算法（Mark-Copying）

为解决标记-清除的缺陷，它会把内存分为两个大小相同的块，然后每次只使用一块，这块内存用完了，就将存活的对象复制到另外一块上面，然后把之前使用的内存对象一次全部清理掉，就不会有内存碎片的问题。

优点：运行高效，不会产生内存碎片

缺点：内存空间利用率低，需要两倍空间，**如果存活对象很多，这个算法效率比较低**（需要复制的对象多）

> 标记-整理 Mark-compact   我觉得叫标记-整理-清除算法，

为了解决copying算法的缺陷，充分利用内存空间

先标记，标记完后再把所有存活的对象移动到**空闲的空间**（会设置一个边界指针），然后再清理掉边界外的内存



> 分代收集算法  **Generational Collection**