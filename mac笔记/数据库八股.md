#### 1、MySQL 为什么使用 B+ 树来作索引，对比 B 树它的优点和缺点是什么？

mysql数据是存在磁盘上的，一次磁盘访问的速度是ms级别远小于内存访问速度，另外mysql是支持范围查询的，所以mysql要设计索引应该要满足下面这些要求：

1、尽可能少的进行磁盘IO

2、能高效的查询某一条记录，也能高效的进行范围查询

首先想到的是二叉查找树O(logn)，但是如果插入是有序的，它会退化为链表，查询效率变成On了，此外树是存储在磁盘中的，访问一个节点就得进行一次磁盘IO，树越高就越影响查询性能

然后平衡二叉查找树，它和二叉查找树的区别是左右两个子树高度相差不能超过1，也就能维持查询效率，另外还有红黑树这种，但是二叉树他们每个节点只能保留2个子节点，数据比较多时，树的高度也会很高。如果我们每个节点允许M个子节点，这就是B树，也叫多叉树，B+树是B树的升级，它们的差异是

- B+的叶子节点存储数据，非叶子节点只存放索引
- 所有索引指向的数据都会在叶子节点出现，叶子节点之间构成一个有序链表
- 非叶子节点的索引

> 和B树比优点和缺点是什么

优点：

- B+树的非叶子节点只存储索引能够存储的记录更多，树的层级更少，查找平均效率会更高
- B+树支持范围查询，叶子节点是一个链表连接起来的 （innoDB的是双向链表）
- B+树遍历更快
- B+树查询速度稳定，都要去叶子节点查询数据
- 插入和删除的效率更高（？？）

缺点：

- B树中查找的数据离根节点近时，查询会更快

#### 2、什么是事务，数据库的事务隔离级别有哪些？各有哪些优缺点？

参考：https://blog.csdn.net/zycxnanwang/article/details/105742160

事务的四个特性



原子性：

- 一个事务中的所有操作，要么都完成，要么都不完成，在执行过程中发生问题，会被回滚到事务开始前的状态
- mysql是通过undo log日志实现的（回滚日志），事务的所有修改操作都会写入到undo log中，**它是一个逻辑文件**，事务无法成功提交，系统会执行undo log中的撤销操作，达到事务回滚的目的

#### 3、简述乐观锁以及悲观锁的区别以及使用场景

#### 4、产生死锁的必要条件有哪些？如何解决死锁？

#### 5、Redis 如何实现分布式锁？

#### 6、简述 Redis 持久化中 RDB 以及 AOF 方案的优缺点

#### 7、简述 Redis 中如何防止缓存雪崩和缓存击穿

8、聚簇索引和非聚簇索引有什么区别？
9、Redis 有几种数据结构？Zset 是如何实现的？
10、简述脏读和幻读的发生场景，InnoDB 是如何解决幻读的？
为什么 Redis 在单线程下能如此快？
什么是数据库事务，MySQL 为什么会使用 InnoDB 作为默认选项
简述什么是最左匹配原则





```sql
select
   distinct cert.emp_id 
from
   cm_log cl 
inner join
   (
      select
         emp.id as emp_id,
         emp_cert.id as cert_id 
      from
         employee emp 
      left join
         emp_certificate emp_cert 
            on emp.id = emp_cert.emp_id 
      where
         emp.is_deleted=0
   ) cert 
      on (
         cl.ref_table='Employee' 
         and cl.ref_oid= cert.emp_id
      ) 
      or (
         cl.ref_table='EmpCertificate' 
         and cl.ref_oid= cert.cert_id
      ) 
where
   cl.last_upd_date >='2013-11-07 15:03:00' 
   and cl.last_upd_date<='2013-11-08 16:00:00';
```

