## 题型

递归：LeetCode70、112、509
分治：LeetCode23、169、240
单调栈：LeetCode84、85、739、503
并查集：LeetCode547、200、684
滑动窗口：LeetCode209、3、1004、1208
前缀和：LeetCode724、560、437、1248
差分：LeetCode1094、121、122
拓扑排序：LeetCode210
字符串：LeetCode5、20、43、93
二分查找：LeetCode33、34
BFS：LeetCode127、139、130、529、815
DFS&回溯：：LeetCode934、685、1102、531、533、113、332、337
动态规划：LeetCode213、123、62、63、361、1230
贪心算法：LeetCode55、435、621、452
字典树：LeetCode820、208、648

## 剑指offer

### 第四题

#### 题目

![image-20210507104403303](https://xy-picgo.oss-cn-shenzhen.aliyuncs.com/20210507104403.png)

#### 思路

> 思路一：暴力破解

从左到右，从上到下，都搜索一遍

时间复杂度:O(mn)

缺点：没有利用给定的矩阵的性质

> 思路二：起始位置搜索，根据矩阵的性质

从左向右，如果target<matrix_i_j的值，就先i++,如果到了右侧边界，就j++,向下一层

给一个标记位flag，向下一层之后如果target>matrix_i_j 就向左移动，此时标记位设置为true。这时候如果target<matrix_i_j的值，就需要根据标记位来判断，可以避免重复扫描

```java
int row = matrix.length;
if(row==0){
    return false;
}  // 边界情况排除，写题目还需要思考极端情况下
int column = matrix[0].length;
int i=0,j=0;
boolean flag =false;
// 同理因为我们有i--，所以i的值不能小于0，边界情况判断
while (i>=0&&i<row&&j<column){
    if(matrix[i][j]==target){
        return true;
    }else if(matrix[i][j]<target){
        if(i+1<row){
            if(flag){
                flag = false;
                if(j<column) { 
                    j++;
                    continue;
                }
                else
                    return false;
            }
            i++;
        }else {
            j++;
        }
    }else {
        i--;
        flag = true;
    }
}
return false;
```

缺点：判断思路太多

时间复杂度无法估算

> 思路三：从最右边的顶点出发

![image-20210507105109324](https://xy-picgo.oss-cn-shenzhen.aliyuncs.com/20210507105109.png)

如果旋转这个矩阵45度角，可以看出这和二叉搜索树很像

时间复杂度O(M+N)

```java
public boolean findNumberIn2DArray2(int[][] matrix, int target){
        int row = matrix.length;
        if(row==0){
            return false;
        }
        int column = matrix[0].length;
        for(int i=column-1,j=0;j<row&&i>=0;){
            if(matrix[j][i]==target){
                return true;
            }else if (matrix[j][i]>target){
                i--;
            }else {
                j++;
            }
        }
        return false;
    }
```

### 1、链表

#### 1.剑指 Offer 24. 反转链表

![image-20210529105152632](https://xy-picgo.oss-cn-shenzhen.aliyuncs.com/20210529105152.png)

> 方法一：头插法

- 省略


> 方法二：递归

```java
public ListNode reverseList(ListNode head){
    // 递归终止条件
    if(head==null|| head.next == null)
        return head;
    //返回的是反转之后的头结点
    ListNode newNode = reverseList(head.next);
    // 通过这里反转链表
    head.next.next = head;
    head.next = null;
    return newNode;
}
```

![image-20210529110716762](https://xy-picgo.oss-cn-shenzhen.aliyuncs.com/20210529110716.png)

这里反转之后，需要把78节点的next指向null

#### 2.剑指offer35

> 复杂链表的复制

![image-20210529113159120](https://xy-picgo.oss-cn-shenzhen.aliyuncs.com/20210529113159.png)

```javascript
  public Node copyRandomList(Node head) {
       if(head == null)
            return head;
        HashMap<Node,Node> map = new HashMap();
        Node cur = head,newH = head;
        // 复制链表里的所有节点
        while(cur!=null){
            map.put(cur,new Node(cur.val));
            cur = cur.next;
        }
        while(newH!=null){
            // 所有的节点都必须地址不一样，也就是从hash表里取出来的
            map.get(newH).next = map.get(newH.next);
            map.get(newH).random = map.get(newH.random);
            newH = newH.next; 
        }
        return map.get(head);
    }
```

#### 3、两个链表的第一个公共节点

![image-20210529114321544](https://xy-picgo.oss-cn-shenzhen.aliyuncs.com/20210529114321.png)

没有相交就输出null

> 解法：A+B  B+A

秒



### 2、树

#### 1.最近公共祖先



![image-20210530211711831](https://xy-picgo.oss-cn-shenzhen.aliyuncs.com/20210530211711.png)

> 解法1：递归DFS

可以知道只有节点的满足如下条件时，才是两个节点的公共祖先:

lson 指的是左树含有两个节点中的一个，同理rson是右子树含有两个节点中的一个

`(lson&&rson) || ((lson||rson)&&(root.val == p.val || root.val==q.val ))`

上面的解释是：左右子树分别含有两个节点中的一个 **或者** 这个节点是p和q中的一个，另一个是其子树的节点

**代码**

```java
/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode(int x) { val = x; }
 * }
 */
class Solution {
    // 定义一个全局变量保存找到的节点
    private TreeNode ans = null;

    public TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) {
        dfs(root,p,q);
        return ans;
    }

    // 递归算法
    public boolean dfs(TreeNode root, TreeNode p, TreeNode q){
        // 当该节点为空时，必然是false
        if(root==null)
            return false;
        // 左右子树是否有p、q中的一个
        boolean lson = dfs(root.left,p,q);
        boolean rson = dfs(root.right,p,q);
        // 我们上面的条件
        if((lson&&rson) || ((lson||rson)&&(root.val == p.val || root.val==q.val )) ){
            // 保存正确的节点
            ans = root;
        }
        // 对该节点正确性判断 
        // 当这个节点的子树有节点p、q的一个或者该节点就是p、q中的一个，则返回true，否则返回else
        return (lson||rson) || (root.val==p.val || root.val==q.val);
    }
}
```

> 解法2：哈希表记录父节点

思路：哈希表 key表示当前的节点，value表示父节点  **相当于**  存下了该节点到父节点的指针

然后对节点p找到其所有的父节点，存在另一个记录表visit中

对节点q找父节点，并与记录表visit进行比较，如果有这个值，则是最近公共祖先

```java
Map<TreeNode ,TreeNode> map = new HashMap<>();
List<Integer> visit = new ArrayList<>();
public TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) {
    dfs(root);
    while (p!=null){
        visit.add(p.val);
        p = map.get(p);;
    }
    while (q!=null){
        if(visit.contains(q.val))
            return q;
        q = map.get(q);
    }
    return null;
}

public void dfs(TreeNode root){
    if(root.left!=null){
        map.put(root.left,root);
        dfs(root.left);

    }
    if (root.right!=null){
        map.put(root.right,root);
        dfs(root.right);
    }
}
```



> 类似题目

**二叉搜索树**的最近公共祖先,利用二叉搜索树的性质，节点左边的数都比他小，右边的比他大

就有三种情况，如果节点的值即大于p又大于q，则p、q在节点的左子树下，如果两个都是小于，就说明p和q都在节点的右子树下，

以上两种情况都不是的话，就说明在这个树的两侧，这个节点就是他们的公共祖先。

![image-20210531202011473](https://xy-picgo.oss-cn-shenzhen.aliyuncs.com/20210531202018.png)

```java
class Solution {
    public TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) {
        if (p.val<root.val && q.val<root.val) return lowestCommonAncestor(root.left,p,q);
        if (p.val>root.val && q.val>root.val) return lowestCommonAncestor(root.right,p,q);
        return root;
    }
}
```

#### 2.平衡二叉树判定问题

> 剑指offer55

输入一棵二叉树的根节点，判断该树是不是平衡二叉树。如果某二叉树中任意节点的左右子树的深度相差不超过1，那么它就是一棵平衡二叉树。

> 方法1：dfs直接判断

```java
 public boolean isBalanced(TreeNode root) {
        if(root==null)
            return true;
        if(Math.abs(dfs(root.left)-dfs(root.right))>1)
            return false;
        
        return isBalanced(root.left)&&isBalanced(root.right);

    }

    public int dfs(TreeNode root){
        if(root==null)
         return 0;
        return Math.max(dfs(root.left),dfs(root.right))+1;
    }
```

> 方法2：dfs加剪枝，减少递归深度

剪枝的原理，因为这里只需要看是不是平衡二叉树，当判断有任意子树不满足条件之后，就无需往下递归了。

**设置标记值为-1.**

```java
public boolean isBalanced(TreeNode root) {
        return dfs(root)!=-1;
    }

    public int dfs(TreeNode root){
        if(root==null)
          return 0;
        int left = dfs(root.left);
        // 增加两个判断条件，子树的高度为-1直接返回
        if(left==-1)  return -1;
        int right = dfs(root.right);
        if(right==-1)  return -1;
        // 当两个子树相差大于等于2，返回高度为-1，否则返回正常的树的深度
        return  Math.abs(left-right)<2 ? Math.max(left,right)+1 :-1;
    }
```

#### 3.二叉树和为某一值的路径

![image-20210601213558361](https://xy-picgo.oss-cn-shenzhen.aliyuncs.com/20210601213558.png)

解题思路：

先序遍历+ 回溯法。 利用回溯法记录路径上的节点。这里我们使用全局变量`LinkedList path`

当遇到底部的栈弹出的时候，把最后加出来的节点释放.

```java
List<List<Integer>> ans = new ArrayList();
LinkedList<Integer> path = new LinkedList<>();
public List<List<Integer>> pathSum(TreeNode root, int target) {

    dfs(root,target);
    return ans;
}

public void dfs(TreeNode root,int target) {
    if (root == null)
        return;
    int value = root.val;
    path.add(value);
    if (value == target && root.right == null && root.left == null) {
        // 这个路径存放起来
        // 这里不能直接ans.add(path) 因为添加的是地址，直接加path之后出栈的话，会清空元素
        ans.add(new LinkedList(path));
    }
    target -= value;
    dfs(root.left, target);
    dfs(root.right, target);
    path.removeLast();
}
```

#### 4.序列化二叉树

![image-20210602182319723](https://xy-picgo.oss-cn-shenzhen.aliyuncs.com/20210602182319.png)

```java
/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode(int x) { val = x; }
 * }
 */
public class Codec {

     public String serialize(TreeNode root) {
       if(root==null) return "[]";
        StringBuffer str= new StringBuffer();
        str.append("[");
        Queue<TreeNode> queue = new LinkedList();
        queue.add(root);
        str.append(root.val+",");
        while (!queue.isEmpty()){
            for(int i=queue.size();i>0;i--){
                TreeNode node = queue.poll();
                if(node.left!=null) {
                    queue.add(node.left);
                    str.append(node.left.val+",");
                }else if(node.right!=null) str.append("null"+",");
                if(node.right!=null) {
                    queue.add(node.right);
                    str.append(node.right.val+",");
                }else if(node.left!=null)  str.append("null"+",");

                if(node.left==null&&node.right==null)  str.append("null,"+"null,");
            }
        }
        str.replace(str.length()-1,str.length(),"]");
        return  str.toString();
    }

    // Decodes your encoded data to tree.
    public TreeNode deserialize(String data) {
        if(data.equals("[]")) return null;
        String[] str = data.substring(1,data.length()-1).split(",");
        TreeNode root = new TreeNode(Integer.valueOf(str[0]));
        Queue<TreeNode> queue = new LinkedList<>();
        queue.add(root);
        int i=1;
        while(!queue.isEmpty()&&i<str.length){
            TreeNode node = queue.poll();
            if(!str[i].equals("null")){
                node.left = new TreeNode(Integer.valueOf(str[i]));
                queue.add(node.left);
            }
            i++;
            if(!str[i].equals("null")){
                node.right = new TreeNode(Integer.valueOf(str[i]));
                queue.add(node.right);
            }
            i++;
        }
        return root;
    }

}

// Your Codec object will be instantiated and called as such:
// Codec codec = new Codec();
// codec.deserialize(codec.serialize(root));
```

### 3.栈和队列

#### 1.用两个栈实现队列

![image-20210602182635599](https://xy-picgo.oss-cn-shenzhen.aliyuncs.com/20210602182635.png)

> 分析

怎么用两个栈模拟队列？难点在于弹出元素---  可以在出栈的时候，将stack1的元素依次出来放如stack2里，然后弹出stack2的元素，就是正常的出队列的顺序.**如下图**(leetcode节选)

![jianzhi_9](https://xy-picgo.oss-cn-shenzhen.aliyuncs.com/20210602183025.gif)

```java
class CQueue {
    private Stack<Integer> stack1;
    private Stack<Integer> stack2;
    
    public CQueue() {
        this.stack1 = new Stack<>();
        this.stack2 = new Stack<>();
    }
    
    public void appendTail(int value) {
        stack1.add(value);
    }
    
    public int deleteHead() {
         if(stack1.isEmpty()&&stack2.isEmpty())  return -1;
        if(!stack1.isEmpty()&&stack2.isEmpty()){
            while (!stack1.isEmpty()){
                Integer val = stack1.pop();
                stack2.add(val);
            }
        }
        return stack2.pop();
    }
}

/**
 * Your CQueue object will be instantiated and called as such:
 * CQueue obj = new CQueue();
 * obj.appendTail(value);
 * int param_2 = obj.deleteHead();
 */
```

#### 2.含有min函数的栈--O(1)

![image-20210602194851604](https://xy-picgo.oss-cn-shenzhen.aliyuncs.com/20210602194851.png)



> 分析

借助辅助栈存放最小的元素，push的时候将x与辅助栈栈顶的元素进行比较，小于的话就放进辅助栈

```java
class MinStack {
    Stack<Integer> stackA ;
    Stack<Integer> stackB;
    int buttom,top;
    /** initialize your data structure here. */
    public MinStack() {
       this.stackA = new Stack(); 
       this.stackB = new Stack();
    }
    
    public void push(int x) {
        stackA.add(x);
        // 这里的等于号必须有，要是有两个相等的最小值，必须添加到辅助栈里面
        if(stackB.isEmpty()||stackB.peek()>=x)
            stackB.add(x);
    }
    
    public void pop() {
        int v = stackA.pop();
        // 出栈的时候和辅助栈的栈顶元素进行比较，如果相同，就是最小元素出栈了，辅助栈也要弹出
        if(v==stackB.peek())
            stackB.pop();
    }
    
    public int top() {
       return stackA.peek();
    }
    
    public int min() {
        return stackB.peek();
    }
}

/**
 * Your MinStack object will be instantiated and called as such:
 * MinStack obj = new MinStack();
 * obj.push(x);
 * obj.pop();
 * int param_3 = obj.top();
 * int param_4 = obj.min();
 */
```

#### 3.含有max()的队列-- O(1)

![image-20210603113045113](https://xy-picgo.oss-cn-shenzhen.aliyuncs.com/20210603113045.png)

> 分析

难点在于怎么O(1)操作定位最大值。  根据上面的带min的栈的思路，可以知道借助辅助空间来实现。

如何实现max？  这里借助一个双端队列--`Deque d`

**入队列**： 元素x入队列q，循环 判断d是否空，是如果不为空就判断d队列的尾部元素的值是否小于x，是的话就将这个尾部元素出队列。一直将所有小于x的值都出队列。

然后元素x入队列d的尾部。

**出队列：**元素x出队列q，然后把x与队列d中的顶点元素进行比较，两个值相等的话就让d中的顶点出队列。

**max：**双端队列d里的顶部元素就是最大值。

```java
class MaxQueue {
    Queue<Integer> q;
    Deque<Integer> d;

    public MaxQueue() {
        q = new LinkedList<Integer>();
        d = new LinkedList<Integer>();
    }
    
    public int max_value() {
        if (d.isEmpty()) {
            return -1;
        }
        return d.peekFirst();
    }
    
    public void push_back(int value) {
        while (!d.isEmpty() && d.peekLast() < value) {
            d.pollLast();
        }
        d.offerLast(value);
        q.offer(value);
    }
    
    public int pop_front() {
        if (q.isEmpty()) {
            return -1;
        }
        int ans = q.poll();
        if (ans == d.peekFirst()) {
            d.pollFirst();
        }
        return ans;
    }
}

```



#### 4.滑动窗口的最大值

Offer59

![image-20210603142601610](https://xy-picgo.oss-cn-shenzhen.aliyuncs.com/20210603142601.png)



> 解法1：暴力破解

**LeetCode的测试用例会超时**

```java
class Solution {
     public int[] maxSlidingWindow(int[] nums, int k) {
        if(nums.length==0) return new int[0];
        int[] ans = new int[nums.length-k+1];
        int max=Integer.MIN_VALUE;
        for(int i=0;i<k;i++){
            if(nums[i]>max) max = nums[i];
        }
        ans[0] = max; 
        for(int i=1;k+i<=nums.length;i++){
            if(nums[k+i-1]>=max){
                max = nums[k+i-1];
            }else{ 
                max=Integer.MIN_VALUE;
                for(int j=0;j<k;j++){
                    if(nums[j+i]>max) max = nums[j+i];
                } 
            }
            ans[i] = max;
        } 
        return ans;
    }
}
```

记录index ，剪枝版本

```java
public int[] maxSlidingWindow(int[] nums, int k) {
    if(nums.length==0) return new int[0];
    int[] ans = new int[nums.length-k+1];
    int max=Integer.MIN_VALUE,index=0;
    for(int i=0;i<k;i++){
        if(nums[i]>max){
            max = nums[i];
            index = i;
        }
    }
    ans[0] = max; 
    for(int i=1;k+i<=nums.length;i++){
        if(nums[k+i-1]>=max){
            index = k+i-1;
            max = nums[k+i-1];
        }else if(nums[k+i-1]<max&& index<i){
            max=Integer.MIN_VALUE;
            for(int j=0;j<k;j++){
                if(nums[j+i]>max){
                    max = nums[j+i];
                    index = j+i;
                }
            }
        }

        ans[i] = max;
    }
    return ans;
}
```

> 解法2：这道题可以看成是上面max()的队列的变形

滑动窗口可以看成是一个固定长度的队列，**每次滑动就是一次出队列，入队列的过程**。于是可以借助一个双端队列记录max的值。方法同上。

```java
public int[] maxSlidingWindow(int[] nums, int k) {
    if(nums.length==0)
        return new int[0];
    // 保存滑动窗口里面最大的值
    int[] ans = new int[nums.length-k+1];
    Deque<Integer> queue = new LinkedList();
    
    // 将起始端口的元素入栈
    for(int i=0;i<k;i++ ){
        while(!queue.isEmpty()&&nums[i]>queue.peekLast())
            queue.pollLast();
        queue.offerLast(nums[i]);
    }
    // 双端队列的顶部元素为最大值
    ans[0] = queue.peekFirst();
    for(int i=1;i+k<=nums.length;i++){
        // 出栈的过程
        int out = nums[i-1];
        if(queue.peekFirst()==out) queue.pollFirst();
        // 还需要入栈的过程
        while(!queue.isEmpty()&&nums[i+k-1]>queue.peekLast()){
            queue.pollLast();
        }
        queue.offerLast(nums[i+k-1]);
        
         // 双端队列的顶部元素为最大值
        ans[i] = queue.peekFirst();
    }
    return ans;
}
```

### 4、堆

#### 1.求第K大或小的数

![image-20210603204114215](https://xy-picgo.oss-cn-shenzhen.aliyuncs.com/20210603204114.png)

> 解法：堆

先维护一个包含k个元素的最大堆，然后每次有新元素加进来的时候，用最大的值和新元素比较，如果新元素小于堆顶元素，则堆顶元素出堆，新元素入堆。当所有元素都过一遍后，堆里面就是整个数组的k个最小元素的集合。

在java中使用`PriorityQueue` 队列创建堆。当比较器用` return num2 - num1; `时是**大根堆**，反之是小根堆。

```java
class Solution {
    public int[] getLeastNumbers(int[] arr, int k) {
        int[] vec = new int[k];
        if (k == 0) { // 排除 0 的情况
            return vec;
        }
        // 大根堆
        PriorityQueue<Integer> queue = new PriorityQueue<Integer>(
            (num1,num2)->{
                return num2 - num1;    
        });

        for(int i=0;i<k;i++){
            queue.offer(arr[i]);
        }
        for(int i=k;i<arr.length;i++){
            if(arr[i]<queue.peek()){
                queue.poll();
                queue.offer(arr[i]);
            } 
        }
        int[] ans = new int[k];
         for(int i=0;i<k;i++){
           ans[i] =  queue.poll();
        }
        return ans;
    }
}
```

### 5、动态规划

#### 1.连续子数组的最大和

输入一个整型数组，数组中的一个或连续多个整数组成一个子数组。求所有子数组的和的最大值。

要求时间复杂度为O(n)。



**示例1:**

​	**输入**:  nums = [-2,1,-3,4,-1,2,1,-5,4]
​	**输出**:  6
​	**解释**:  连续子数组 [4,-1,2,1] 的和最大，为 6。

> 解法：动态规划

**状态定义**： 

- 设动态规划列表 *dp* ，*dp[i]* 代表以元素*num[i]*为结尾的连续子数组最大和。 
- 一定要包含元素nums[i]。保证*dp[i]* 递推到 *dp[i+1]*的正确性

**转移方程**：两种情况

- 当dp[i-1] >=0时，前一个状态是正反馈，dp[i] = nums[i]+dp[i-1]
- 当dp[i-1] <0时，前一个状态是负反馈，dp[i] = nums[i]

```java
public int maxSubArray2(int[] nums) {
    // 以nums[i]结尾的最大的连续子数组的和
    int[] dp = new int[nums.length];
    dp[0] = nums[0];
    int max=dp[0];
    for(int i=1;i<nums.length;i++){
        dp[i] = nums[i] + ((dp[i-1]>0)? dp[i-1]:0); 
        if(max<dp[i]) max = dp[i];
    }
    return max;
}
```

> 优化空间

因为下一个状态只和前一个状态有关，所以可以用原来的数组nums直接存放dp的过程

```java
public int maxSubArray(int[] nums) {
    // 以nums[i]结尾的最大的连续子数组的和
    int max = nums[0];
    for(int i = 1; i < nums.length; i++) {
        nums[i] += Math.max(nums[i - 1], 0);
        max = Math.max(max, nums[i]);
    }
    return max;
}
```

#### 2.剪绳子

![image-20210605214631894](https://xy-picgo.oss-cn-shenzhen.aliyuncs.com/20210605214631.png)



> 解法：动态规划

dp[i] ：表示长度为i的绳子切割之后的最大乘积

转移方程： 先切割j长度，对i-j的长度有两个选择，一个是继续切割，一个是不切割。

- dp[i] = j*(i-j)  or j\*(dp[i-j])  看谁比较大
- dp[i] 因为j的长度变化，所以还需要把dp[i]之前的和现在的比较大小。如果新产生的比较大，就存放新产生的

```java
public int cuttingRope(int n) {
    int[] dp = new int[n+1];
    dp[2] = 1;
    for(int i =3;i<=n;i++){
        int max = 0;
        for(int j=2;i-j>=1;j++){
            max = Math.max(Math.max(j*(i-j),j*dp[i-j]),dp[i]);
            dp[i] = max;
        }

    }
    return dp[n];
}
```

#### 3.股票的最大利润

##### 1.一次买卖

![image-20210606144607798](https://xy-picgo.oss-cn-shenzhen.aliyuncs.com/20210606144607.png)

> 解题思路：动态规划

dp\[i][0] 表示第i天结束后,卖出了手里的股票

dp\[i][1] 表示第i天结束后,手里还拿着股票

**转移方程：**

dp\[i][0] = max(dp\[i-1][0],dp\[i-1][1]+price[i])  (第i天卖出，从两个里面选，一个是前一天就买出的收益，或者前一天不卖出，今天卖出。)

dp\[i][1] = min(dp\[i-1][1],-price[i]) // 这里没有卖出去，收益是负的,两个负数比较谁小，就用Math.max

```java
if(prices.length<2)
    return 0;
int[][] dp = new int[prices.length][2];
dp[0][1] = -prices[0];
for(int i=1;i<prices.length;i++){
    dp[i][0] = Math.max(dp[i-1][0],dp[i-1][1] + prices[i]);
    dp[i][1] = Math.max(dp[i-1][1],-prices[i]);
}
return dp[prices.length-1][0];
```

> 解题思路：一次遍历

可以知道，股票要获得最大收入，必然是前面用最低价买入，后面用最高价卖出，即可获得最大收益

定义一个最低价，这个是动态变化的。然后每次根据今天是卖或是不卖，来判定最大的收益

```java
if(prices.length<2)
    return 0;
// 这里的思路就是记录第i天之前的最低买入价格，之后卖出的话记录最大收益，
// 最低买入价格变化之后，前面的数据就没用了，但是卖出的最大收益还是记录着，之后的再继续比较
int minPrice =prices[0];
int maxProfiet = 0;
for(int i=1;i<prices.length;i++){
    if(minPrice>prices[i]){
        minPrice = prices[i];
    }else{
        if(maxProfiet<prices[i]-minPrice)
            maxProfiet = prices[i]-minPrice;
    }
}
return maxProfiet;
```

#### 4.正则表达式

![image-20210609211719487](https://xy-picgo.oss-cn-shenzhen.aliyuncs.com/20210609211719.png)

> 思路分析

标志：返回true或false  --- 动态规划

用f\[i][j] 表示s的前i个字符和p中的前j个字符是否匹配。

转移方程：

- 1.当p中的第j个字符是字母，s中必须匹配相同的小写字母 

  - ```
    f[i][j] = f[i-1][j-1]   if s[i] = p[j]
    f[i][j] = false   s[i] != p[j]
    ```

- 2.p中的第j个字符是*，就表示对p中的第j-1个字符匹配任意次。

  - ```
    f[i][j] = f[i][j-2]   //匹配0次
    f[i][j] = f[i-1][j-2]  // 匹配多次
    ```

  - ![image-20210609212439773](https://xy-picgo.oss-cn-shenzhen.aliyuncs.com/20210609212439.png)

- 3.当p[j] 是`.`，一定匹配成功

最终的转移方程

![image-20210609212528160](https://xy-picgo.oss-cn-shenzhen.aliyuncs.com/20210609212528.png)



边界条件f\[0][0] = true 两个空字符串一定匹配成功

> 代码

```java
public boolean isMatch(String s, String p) {
    char[] str = s.toCharArray();
    char[] patterns = p.toCharArray();

    // dp[i][j]  s长度为i的字串是否匹配 长度为j的p
    boolean[][] dp = new boolean[str.length+1][patterns.length+1];
    dp[0][0] = true;
    for (int i=0;i<str.length+1;i++){
        for(int j=1;j<patterns.length+1;j++){
            if(patterns[j-1]!='*'){
                if(i>=1&&matches(str[i-1],patterns[j-1])){
                    dp[i][j] = dp[i-1][j-1];
                }// 因为boolean初始化为false，不需要写else     
            }else {
                if(j<2) continue; // 这里加上了p的第一个元素为*的判断
                dp[i][j] = dp[i][j-2];
                if(i>=1&&matches(str[i-1],patterns[j-2])){
                    dp[i][j] = dp[i-1][j] || dp[i][j-2];
                }
            }
        }
    }
    return dp[str.length][patterns.length];
}
public boolean matches(char s,char p){
    if(p=='.') return true;
    if(s==p) return true;
    return  false;
}
```



### 6、数组

#### 1.顺时针打印矩阵

![image-20210609213431424](https://xy-picgo.oss-cn-shenzhen.aliyuncs.com/20210609213431.png)

> 思路

模拟矩阵的路线  .**好好看代码，很舒服**

```java
class Solution {
    public int[] spiralOrder(int[][] matrix) {
         if (matrix.length == 0) {
            return new int[0];
        }
        int[] res = new int[matrix.length * matrix[0].length];
        int u = 0, d = matrix.length - 1, l = 0, r = matrix[0].length - 1;
        int idx = 0;
        while (true) {
            for (int i = l; i <= r; i++) {
                res[idx++] = matrix[u][i];
            }
            if (++u > d) {
                break;
            }
            for (int i = u; i <= d; i++) {
                res[idx++] = matrix[i][r];
            }
            if (--r < l) {
                break;
            }
            for (int i = r; i >= l; i--) {
                res[idx++] = matrix[d][i];
            }
            if (--d < u) {
                break;
            }
            for (int i = d; i >= u; i--) {
                res[idx++] = matrix[i][l];
            }
            if (++l > r) {
                break;
            }
        }
        return res;
    }
}
```

##### 2. 缺失的数字

![image-20210609213542268](https://xy-picgo.oss-cn-shenzhen.aliyuncs.com/20210609213542.png)

> 解法一：从前扫描到最后

时间复杂度：O(n)

```java
if(nums.length==1) 
    return 1-nums[0];

for(int i=0;i<nums.length;i++){
    if(nums[i]!=i)
        return i;
}
return nums.length;
```

> 解法二：二分查找

对这种有顺序的，进行搜素，应该想到二分查找。这里找的数x

- 左子数组：nums[i] = i
- 右子数组：nums[i] != i

![image-20210609214236165](https://xy-picgo.oss-cn-shenzhen.aliyuncs.com/20210609214236.png)

缺失的数字等于 **“右子数组的首位元素”** 对应的索引；因此考虑使用二分法查找 “右子数组的首位元素”

**返回值：** 跳出时，变量 i和 j分别指向 “右子数组的首位元素” 和 “左子数组的末位元素” 。因此返回 i*i* 即可。

时间复杂度：**O(logn)**

```java
int i=0,j=nums.length-1;
int m=0;
while(i<=j){
    m = (i+j) / 2;
    if(nums[m]>m)  j = m-1;
    else  i =m+1;      
}
return i;
```

### 7、回溯

> 字符串的排列

![image-20210617111622061](https://xy-picgo.oss-cn-shenzhen.aliyuncs.com/20210617111622.png)



### 8、滑动窗口

![image-20210617212722485](https://xy-picgo.oss-cn-shenzhen.aliyuncs.com/20210617212722.png)

> 解法1：滑动窗口（这里需要是连续的）

滑动窗口的左边界，向右边扩张，使用set来存放滑动窗口里面的值(判断条件，如果set里面没有同样的元素，就滑动窗口右边增加1，如果有相同的元素，就去掉左边界右移一位)，一次遍历后，得到最大的长度就是答案

```java
public int lengthOfLongestSubstring(String s) {
    //滑动窗口
    char[] chars = s.toCharArray();
    HashSet<Character> set = new HashSet(); 
    int ans=0,r = -1;
    for(int i=0;i<chars.length;i++){
        if(i!=0){
            set.remove(chars[i-1]);
        }
        while(r+1<chars.length &&!set.contains(chars[r+1])){
            set.add(chars[r+1]);
            r++;
        }

        ans = Math.max(ans,r+1-i);
    }
    return ans;
}
```

> 解法2:动态规划

`dp[j]` 是以`s[j]`为结尾的最长不重复字串的长度

固定j,向左边扩张，假设左侧最近的相同字符为s[i]

有下面几种情况：

- dp[j-1] >= j-i   ：意味着s[i]在dp[j-1]的区间内。所以dp[j]的左边界由i决定 dp[j] = j-i
- dp[j-1] < j-i ：以为这s[i]在dp[j-1]的区间外，dp[j] = dp[j-1] +1;

```java
public int lengthOfLongestSubstring(String s) {
    Map<Character,Integer> dic = new HashMap<>();
    char[] chars = s.toCharArray();
    int res = 0,temp = 0;
    for(int j=0;j<chars.length;j++){
        int i = dic.getOrDefault(chars[j],-1); // 确定是否含有这个字符
        dic.put(chars[j],j); // 更新哈希表,这个字符最近的位置
        if(temp<j-i) temp = temp+1;   // 这里的temp是前一个dp[i-1]
        else temp = j-i;
        res = Math.max(res,temp);
    }
    return res;
}
```



### 9、数学

#### 剑指offer62--约瑟夫环问题

![image-20210618092013692](https://xy-picgo.oss-cn-shenzhen.aliyuncs.com/20210618092013.png)



> 数学解法

![image-20210618092048805](https://xy-picgo.oss-cn-shenzhen.aliyuncs.com/20210618092048.png)

每次删除的是红色部分。最后留下的那个下标必然为0，于是我们倒退回去就能只能知道它在原数组的index。

第一次倒退，补上m个位置 0+3 mod 2 = 1

第二次倒退，补上m个位置 1+3 mod 3 = 1

第三次倒退，补上m个位置 1+3 mod 4 = 0

第四次倒退，补上m个位置 0+3 mod 5 = 3

 最终剩下的下标就是3，在原数组里的位置是数字3

```java
class Solution {
    public int lastRemaining(int n, int m) {
        int ans = 0;
        for(int i =2;i<n+1;i++){
            ans = (ans+m)%i;
        }
        return ans;
    }
}
```

### 10、二分

[二分文章1](https://leetcode-cn.com/problems/find-first-and-last-position-of-element-in-sorted-array/solution/si-lu-hen-jian-dan-xi-jie-fei-mo-gui-de-er-fen-cha/)  [二分文章2](https://leetcode-cn.com/problems/find-first-and-last-position-of-element-in-sorted-array/solution/da-jia-bu-yao-kan-labuladong-de-jie-fa-fei-chang-2/)

### 、其他

#### 1.

>[剑指 Offer 64. 求1+2+…+n](https://leetcode-cn.com/problems/qiu-12n-lcof/)

![image-20210617210257658](https://xy-picgo.oss-cn-shenzhen.aliyuncs.com/20210617210257.png)

> 解法

不能使用乘法，所以想到了循环加法。

递归来实现循环，但是递归需要用终止条件，也就是进行判断，用短路&&来进行判断。

一个性质就是前面是false后面就不执行

```java
public int sumNums(int n) {
    Boolean q = ( !(n==0) && (n=(n+sumNums(n-1))) >0);
    return  n;
}
```

或者用try catch判断

```java
class Solution {
    int[] test=new int[]{0};
    public int sumNums(int n) {
        try{
            return test[n];
        }catch(Exception e){
            return n+sumNums(n-1);
        }
    }
}
```

#### 2. Offer 56

![image-20210619193854880](https://xy-picgo.oss-cn-shenzhen.aliyuncs.com/20210619193854.png)

> 解法：位运算

加入nums里面出现一次的数字为a和b，如果把nums里面的所有数字都异或，就可以得到a异或b的结果 ，假设为x。

那么如何分别求出a和b了，就需要分组。

我们a！=b，所以x！=0，于是我们可以x = $x_0x_1x_2x_3...x_n$ 每个x表示0 or 1.我们找到第一个为1的位数$x_i$ 。然后根据这个将nums分为两组，a和b必然在不同的组里面。因为$x_i$ =1，a和b在i位置的数必然是不同的，也就是一个是0，一个是1 。

```java
class Solution {
    public int[] singleNumbers(int[] nums) {
        int num = 0;
        for(int n:nums){
            num ^= n;
        }
        // x中第一次出现1的数,比如num =(1001)9  x=1 ，num=(1000)8 x = 8
        int x = num&(-num),a=0,b=0;
        
        for(int n:nums){
            // 在第i位，位置是0的分到这个组
            if((x&n)==0) a ^= n;
            // 第i为位置是1的，分到这个组
            else b ^=n;
        }
        return new int[]{a,b};
    }
}
```

### 位运算

![image-20210619200339558](https://xy-picgo.oss-cn-shenzhen.aliyuncs.com/20210619200339.png)



#### 1.

![image-20210621164742482](C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20210621164742482.png)

> 解题

![](https://xy-picgo.oss-cn-shenzhen.aliyuncs.com/20210621164958.png)

```java
class Solution {
    public int singleNumber(int[] nums) {
        int[] count = new int[32];
        for(int i=0;i<nums.length;i++){
            for(int j=0;j<32;j++){
                count[j] +=nums[i]&1;
                nums[i] = nums[i]>>1; 
            }
        }
        // 算出来每一位的值了，接下来就是算结果
        int ans = 0;
        for(int i=31;i>=0;i--){
            int num = count[i]%3;
            ans += num;
            if(i==0) break;
            ans = ans<<1;
        }
        return ans;
    }
}
```







## 各种题型

### 1、背包问题

常见的背包类型主要有以下几种：
1、0/1背包问题：每个元素最多选取一次
2、完全背包问题：每个元素可以重复选择
3、组合背包问题：背包中的物品要考虑顺序
4、分组背包问题：不止一个背包，需要遍历每个背包



而每个背包问题要求的也是不同的，按照所求问题分类，又可以分为以下几种：
1、最值问题：要求最大值/最小值
2、存在问题：是否存在…………，满足…………
3、组合问题：求所有满足……的排列组合





## 多线程



### 1.顺序打印A1B2C3的几种写法

#### 1.synchronized + notify+wait



这里的CountDownLatch是 两个线程执行完之后再返回main线程执行，阻止main线程的执行

```java
import java.util.concurrent.CountDownLatch;
public class PrintTest {
    static Thread t1;
    static Thread t2;
    public static void main(String[] args) throws InterruptedException {
        CountDownLatch countDownLatch = new CountDownLatch(2);
        Object o  = new Object();
        t1 =new Thread(){
            @Override
            public void run() {
                synchronized (o) {
                    for (int i = 0; i < 26; i++) {
                        System.out.print(i%10);
                        try {
                            //wait会释放相关锁
                            //唤醒因wait导致阻塞的t2线程
                            o.notify();
                            //使t1线程阻塞
                            o.wait();
                        } catch (InterruptedException e) {
                            e.printStackTrace();
                        }
                    }
                    //                    循环完后不用notify程序不会停止
                    o.notify();
                    countDownLatch.countDown();
                }
            }
        };
        t2=new Thread(){
            @Override
            public void run() {
                synchronized (o) {
                    for (int i = 0; i < 26; i++) {
                        System.out.print((char)('A'+i));
                        try {
                            //唤醒因wait导致阻塞的t1线程
                            o.notify();
                            //使t2线程阻塞
                            o.wait();
                        } catch (InterruptedException e) {
                            e.printStackTrace();
                        }
                    }
                    // 循环完后不用notify程序不会停止
                    o.notify();
                    countDownLatch.countDown();
                }
            }
        };
        t2.start();
        t1.start();

        countDownLatch.await();
        System.out.println();
        System.out.println("main");
    }
}
```

#### 2、LockSupport

```java
import java.util.concurrent.locks.LockSupport;
public class AlternatePrint {

    static Thread t1 = null, t2 = null;

    public static void main(String[] args) {
        char[] aI = "1234567".toCharArray();
        char[] aC = "ABCDEFG".toCharArray();

        t1 = new Thread(new Runnable() {
            @Override
            public void run() {
                for (int i = 0; i < aC.length; i++) {
                    // 起始先打印一个字母
                    System.out.println(aC[i]);
                    // 打印完唤醒t2打印数字
                    LockSupport.unpark(t2);
                    // 自己阻塞，等待唤醒
                    LockSupport.park();
                }
            }
        });

        t2 = new Thread(new Runnable() {
            @Override
            public void run() {
                for (int i = 0; i < aI.length; i++) {
                    // 起始先阻塞等待
                    LockSupport.park();
                    // 被唤醒后打印数字
                    System.out.println(aI[i]);
                    // 唤醒t1
                    LockSupport.unpark(t1);
                }
            }
        });

        t1.start();
        t2.start();
    }

}
```

