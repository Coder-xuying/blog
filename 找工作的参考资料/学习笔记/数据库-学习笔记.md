## Mysql

### 1、初始MySQL

#### 1.1、数据库分类

**关系型数据库**：

- mysql，orcal、SQLlite
- 通过表和表之间，行和列之间的关系进行数据的存储。学员信息表，考勤表,...

**非关系型数据库**：(NoSQL) Not Only

- Redis、MongDB
- 非关系型数据库，对象存储，通过对象的自身的属性来决定

DBMS(数据库管理系统)

- 数据库的管理软件，科学有效的管理我们的数据
- mysql

#### 1.2、命令行操作

```sql
-- 代表单行注释注释

/*
多行注释
*/
flush privileges;
--所有的语句都要用;结尾

show databases; -- 查看所有的数据库
use xx;   --切换数据库
show tables; -- 查看数据库中所有的表
describe student；-- 显示数据库中所有表的信息

create database 数据库名; --创建一个数据库

```

### 2、操作数据库

操作数据库-》操作数据库中的表-》操作数据库中表中的数据

**mysql的关键字不区分大小写**

#### 2.1、操作数据库（了解）

敲一下命令就行

> 创建数据库

```sql
CREATE DATABASE if not EXISTS school;
```

> 删除数据库

```sql
DROP	DATABASE IF EXISTS  learn;
```

> 使用数据库

```sql
--如果表名或者字段名是一个特殊字符，就需要带``
use `school`;
```

> 查看数据库

```sql
show databases;
```

#### 2.2、数据库的列类型

> 数值

- tinyint  十分小的数据   1个字节
- smallint  较小的数据    2个字节
- mediumint  中等大小的数据  3个字节
- **int          标准的整数     4个字节**  常用的
- bigint     较大的数据       8个字节

---

- float     浮点数   4个字节
- double    浮点数    8个字节  （**精度问题**）
- decimal   字符串形式的浮点数    **金融计算的时候一般使用decimal**(解决精度的问题)



>  字符串

- char   字符串固定大小   0-255
- varvhar   可变字符串     0~65535      **对应string**
- tinytext     微型文本    2^8 - 1
- text          文本串         2^16 -1

> 时间 日期

java.util.Date

- date     YYYY-MM-DD    日期
- time     HH:mm:ss    时间格式
- **datatime     上面两个加起来     最常用的时间格式**
- timestamp     时间戳      1970.1.1 到现在的毫秒数
- year    年份表示

> null

- 没有值，位置
- ==注意不要使用null 进行运算，结果为NULL==

#### 2.3、数据库的字段属性(重点)

**Unsigned**

- 无符号的整数
- 声明了该列不能声明为负数

**zerofill**

- 0填充
- 不足的维数，使用0来填充。 int(3)  5对应005

**自增**：

- 自动在上一条记录的基础上+1(默认)
- 通常用来设计唯一的主键，index，必须是整数类型
- 可以自定义设计主键的自增的起始值和步长

**非空**  NULL   NOT NULL

- 假设设置为not null ，如果不给它赋值就会报错
- null，如果不写值，默认就是null

**默认**

- 设置默认的值

#### 2.4创建数据库表

```sql
-- 使用英文()，表的名称和字段尽量使用``括起来
-- AUTO_INCREMENT  自增
-- 字符串使用用 ''括起来
-- 所有的语句后面用,  最后一个不用加,
-- PRIMARY KEY 主键
CREATE TABLE iF NOT EXISTS `student`(
	`id` INT(4) NOT	null  AUTO_INCREMENT comment '学号',
	`name` VARCHAR(10)  NOT NULL DEFAULT('匿名') COMMENT '姓名',
	`pwd` VARCHAR(20) NOT NULL DEFAULT('123456') COMMENT '密码',
	`sex`  VARCHAR(2) NOT NULL DEFAULT('女') COMMENT '性别',
	`birthday` Datetime DEFAULT NUll	COMMENT '生日',
	PRIMARY Key(`id`)
)ENGINE = INNODB	DEFAULT CHARSET=utf8
```

> 常用命令

```sql
show CREATE DATABASE learn;    --查看创建数据库的语句
show CREATE	TABLE student;   --查看数据表的创建语句
DESC student;    --显示表的结构
```

#### 2.5、数据表的类型

INNODB       默认使用

MYISAM      早些年使用的

|              | MYISAM | INNODB                |
| ------------ | ------ | --------------------- |
| 事务支持     | 不支持 | 支持                  |
| 数据行锁定   | 不支持 | 支持                  |
| 外键约束     | 不支持 | 支持                  |
| 全文索引     | 支持   | 不支持                |
| 表空间的大小 | 较小   | 较大，约为MYISAM的2倍 |

常规使用：

- MYISAM  节约空间，速度较快
- INNODB  安全性高，事务的处理，多表多用户操作

> 在物理空间存在的位置

所有的数据库文件都存在data目录下

引擎的区别：

- INNODB在数据库表中只有一个.idb文件，以及上级目录下的ibdata1文件**(MYSQL8)**
- MYISAM对应的文件
  - .frm  表结构的定义文件
  - .MYD  数据文件(data)
  - .MYI  索引文件 (index)

> 设置数据库表的字符集编码

`CHARSET=utf8`

不设置的话，会是mysql默认的字符集编码(不支持中文)

##### 2.6、 修改删除表

> 修改

```sql
-- 修改表名
ALTER TABLE teacher RENAME as teacher1;

-- 增加表的字段  ALTER TABLE 表名 ADD 字段名 列属性
ALTER TABLE teacher1 ADD age int(11)

-- 修改表的字段(重命名，修改约束)
ALTER TABLE teacher1 MODIFY `name` VARCHAR(11)   -- 修改约束
ALTER TABLE teacher1 CHANGE age age1 INT(10)   -- 字段重命名

-- 删除表的字段
ALTER TABLE teacher1 DROP age1
```

> 删除

```sql
-- 删除表
DROP TABLE if exists teacher1
```

==所有的创建和删除操作尽量加上判断，以免报错==



### 3、Mysql数据管理

#### 3.1、外键(了解)

> 方式1，在创建表的时候，增加约束

```sql
CREATE TABLE	iF NOT EXISTS `student`(
	`id` INT(4) NOT	null  AUTO_INCREMENT comment '学号',
	`name` VARCHAR(10)  NOT NULL DEFAULT('匿名') COMMENT '姓名',
	`pwd` VARCHAR(20) NOT NULL DEFAULT('123456') COMMENT '密码',
	`sex`  VARCHAR(2) NOT NULL DEFAULT('女') COMMENT '性别',
	`gradeid` int(10) not NULL,
	`birthday` Datetime DEFAULT NUll	COMMENT '生日',
	PRIMARY Key(`id`),
	-- 定义外键key
	-- 给外键添加约束
	KEY `FK_gradeid` (`gradeid`),
	CONSTRAINT `FK_gradeid` FOREIGN KEY (`gradeid` ) REFERENCES `grade`(`gradeid`)
)ENGINE = INNODB	DEFAULT CHARSET=utf8

```

删除有外键关系的表的时候，必须先删除引用别人的表，才能删除这个表。

> 方式二：创建表成功后添加外键约束

```sql
alter TABLE `student` add CONSTRAINT `FK_gradeid` FOREIGN key(`gradeid`) REFERENCES `grade`(`gradeid`)

-- 公式
alter TABLE `表名` ADD CONSTRAINT  `约束名` FOREIGN key(`作为外键的列`)  REFERENCES `关联的表`(`关联表的列`)
```

这里的关联表可以直接删除

---

上面的两种方式都是物理外键，数据库级别的外键，我们不建议使用(避免数据库过多造成困扰)

**最佳实践**：

- 数据库就是单纯的表，只用来存数据，只有行（数据）和列（字段）
- 我们想使用多张表的数据，想使用外键，我们用程序级别的

#### 3.2 、DML语言(全部记住)

DML语言：数据操作语言

- insert
- update
- delete

#### 3.3、添加

> insert

```sql
-- 公式： insert INTO 表名 (字段1，字段2，字段3) VALUES ('值1'，'值2','值3')    字段和值是一一对应的

insert INTO grade (gradename) VALUES ('计算机')


插入多个值
insert INTO 表名 (字段1，字段2，字段3) VALUES ('值1'，'值2','值3'),('值1'，'值2','值3'),('值1'，'值2','值3')
```

#### 3.4、修改

> update  修改，条件  set 原来的值= 新值

```sql
-- 修改学生的名字
UPDATE `student` set `name`= 'xy12' where id=1;

-- 没有条件的话就会改变所有的数据
UPDATE `student` set `name`= 'xy32';

-- 修改多个值
UPDATE `student` set `name`= 'xy32',`pwd`='12aa' WHERE id=1;

语法：

UPDATE `表名` set `列名1`= value1,`列2`= value' WHERE id=1;
```

==where 条件判断==

![image-20210328160628944](https://xy-picgo.oss-cn-shenzhen.aliyuncs.com/20210328160629.png)

set 后面的value,是一个主题的值，也可以是变量

#### 3.5、删除

> delete

```sql
--删除里面的所有的数据
delete from `student`;

DELETE from `student` where id =1;
```

>TRUNCATE

作用：完全清空一个数据库表，表的结构和索引约束不会变

```sql
TRUNCATE `student`;
```

> delete 和 truncate

不同：

- truncate 重新设置 自增列，计数器会归零
- truncate 不会影响事务



==delete的问题==

![image-20210328162201588](https://xy-picgo.oss-cn-shenzhen.aliyuncs.com/20210328162201.png)

### 4、DQL查询数据（最重要）

#### 4.1、DQL

Data Query Language ：数据查询语言

- 数据库中最核心的语句

#### 4.2 指定查询字段

```sql
SELECT `id` ,`name` from student;

-- 别名，给结果起一个名字，AS 可以给字段 也可以给表起别名
SELECT `id` as 学号,`name` as 姓名 FROM student as s

-- 函数 Concat(a,b) 拼接
SELECT CONCAT('姓名:',name) as 名字 FROM student
```

![image-20210328163248087](https://xy-picgo.oss-cn-shenzhen.aliyuncs.com/20210328163248.png)

> 去重  distinct

```sql
select DISTINCT `gradename` FROM grade
```

取出select语句查询出来的重复数据，只显示一条





![image-20210328165629880](https://xy-picgo.oss-cn-shenzhen.aliyuncs.com/20210328165629.png)



#### 4.3、where条件字句

> 逻辑运算符

and 、 or 、 not (与或非)  mysql中也可以用 && || !

```sql
SELECT `gradeid` FROM grade WHERE NOT gradeid=8   -- not的用法，相当于 SELECT `gradeid` FROM grade WHERE  gradeid != 8  
```

> 模糊查询(重点)：比较运算符

| 运算符        | 语法              | 描述                            |
| ------------- | ----------------- | ------------------------------- |
| IS NULL       | a is null         | 如果操作符为NULL，结果为真      |
| IS NOT NULL   | a is not null     | 如果操作符为NOT NULL，结果为真  |
| BETWEEN   AND | a between b and c | 若a在b和c之间，则结果为真       |
| **LIKE**      | a like b          | SQL匹配，如果a匹配b，则结果为真 |
| **IN**        | a in (a1,a2,a3)   |                                 |

```sql

-- 查询名字为xy后面有无数个字的
SELECT `name` FROM teacher1 WHERE `name` LIKE	'xy%'

-- 查询名字为xy后面有一个字的
SELECT `name` FROM teacher1 WHERE `name` LIKE	'xy_'

-- 查询名字带有y的
SELECT `name` FROM teacher1 WHERE `name` LIKE	'%y%'

-- =====in==== in是精确查询

-- 查询id为1,2,3号
SELECT `gradeid` FROM grade WHERE gradeid in (1,2,3)
```

==_ 和%只能在like里面使用==



#### 4.4、联表查询



![image-20210329211358541](https://xy-picgo.oss-cn-shenzhen.aliyuncs.com/20210329211358.png)

==**7中连接查询，还有where 和on的区别**看一下教程==



right join  以右边的表为基本，left join是以左边的表为基本

> 自连接

自己的表和自己的表连接，核心：**一张表拆为两张一样表即可**

![image-20210329220739709](https://xy-picgo.oss-cn-shenzhen.aliyuncs.com/20210329220739.png)

```sql
SELECT a.categoryname as '父类目',  b.categoryname as '子类目' FROM	`category` as a, `category` as b
where b.pid  = a.categoryid  
```

![image-20210329220822624](https://xy-picgo.oss-cn-shenzhen.aliyuncs.com/20210329220822.png)

这张表理解成一个树结构。pid=1 就是根节点

#### 4.5 分页和排序

> 排序

升序 ASC  降序 DESC

```sql
ORDER by xxx  ASC
```

> 分页

为什么分页？

- 缓解数据库的压力
- 给人的体验更好，瀑布流

```sql
-- 语法 limit 起始值 显示数量

SELECT * FROM student LIMIT 1,3
```

#### 4.6、子查询

where (这个值是计算出来的)

本质： `在where语句中嵌套一个查询语句`

```sql
SELECT studentno,subjectno,studentResult FROM result 
WHERE subjectno = (
	SELECT subjectno FROM `subject` WHERE subjectno = 4
)

```

#### 4.7分组和过滤

group by          having  ==去上网学习一下==



#### 4.8、select小结

![image-20210330143344817](https://xy-picgo.oss-cn-shenzhen.aliyuncs.com/20210330143344.png)

### 5、mysql函数

#### 5.1、通用函数

```sql
SELECT ABS(-8)
SELECT CEILING(9.4)  -- 向上取整
SELECT FLOOR(9.4)  -- 向下取整
SELECT RAND()  -- 返回一个个0~1之间的随机数
SELECT SIGN(10)  -- 判断一个数的符号，负数返回-1，正数返回1,0返回0

SELECT CHAR_LENGTH('爱上帝会奇偶if噶几') -- 字符串长度
SELECT CONCAT('i','love','you')  --拼接字符串
-- SELECT INSERT('我爱标称')  查一下吧

SELECT LOWER('AIJAOISD')
SELECT UPPER('joisadjiodjs')  

SELECT INSTR('xuying','y') -- 返回第一次出现的字串的索引

SELECT REPLACE('xuying','xu','hell')  -- 替换出现的制定字符串

SELECT SUBSTR('xuying',2,4) -- 截取 (截取的位置，截取的长度)

SELECT REVERSE('澄清我上吗')  -- 反转
```

> 时间和日期函数

```sql
-- 时间和日期函数
SELECT CURRENT_DATE  -- 获取当前日期
SELECT CURDATE()  -- 获取当前日期
SELECT NOW()  -- 获取当前时间

SELECT LOCALTIME()  -- 本地时间

SELECT SYSDATE()  --  系统时间

SELECT YEAR(NOW())
SELECT MONTH(NOW())
SELECT DAY(NOW())
-- HOUR() MINUTE(time) SECOND(time)
```

> 系统函数

```sql
SELECT SYSTEM_USER()
SELECT USER()
SELECT VERSION()
```

#### 5.2、聚合函数（常用）

| 函数名称 | 描述   |
| -------- | ------ |
| COUNT()  | 计数   |
| SUM（）  | 求和   |
| AVG()    | 平均数 |
| MAX()    | 最大   |
| MIN（）  | 最小   |

```sql
--  下面的都能统计表中的数据
SELECT COUNT(studentname) FROM student;   -- 会忽略所有的null值
SELECT COUNT(*) FROM student;    --  不会忽略null值
SELECT COUNT(1) FROM student;    --  不会忽略null值
```

#### 5.3 数据库级别MD5加密

```sql
-- 数据库表
CREATE table `testmd5`(
	`id` int(10) not null,
	`name` VARCHAR(10) not null,
	`pwd` VARCHAR(55) not null,
	PRIMARY KEY(`id`)
)ENGINE=INNODB DEFAULT charset=utf8


INSERT INTO `testmd5` VALUES(1,'zs','123456')
UPDATE `testmd5` SET pwd = MD5(pwd) -- 加密全部的密码
INSERT INTO `testmd5` VALUES(3,'zs',MD5('123476')) -- 插入的时候加密
SELECT * FROM `testmd5` WHERE `name`='zs' AND `pwd` = MD5('123456')
```

### 6、事务

#### 6.1、什么是事务

****

> 事务原则  ACID （原子性，一致性，隔离性，持久性） 

事务的隔离级别 ：四种隔离级别

（脏读、不可重复读、幻读）

**原子性**：

- 要么都成功，要么都失败

**一致性**：

- 事务前后的数据完整性要保持一致

**持久性**：

- 事务一旦提交则不可逆，被持久化到数据库中

**隔离性**：

- 事务的隔离性是多个用户并发访问数据库时，数据库为每一个用户开启的事务，不能被其他事务的操作数据所干扰。事务之间要相互隔离



> 隔离所导致的一些问题

脏读：一个事务读取了另外一个事务未提交的数据

不可重复读：

幻读：



#### 6.2、执行事务

mysql是默认开启事务自动提交的

```sql
-- 事务的操作

-- mysql 是默认事务自动提交的

SET autocommit = 0 /*关闭*/
SET autocommit = 1   -- 开启，默认的


SET autocommit = 0 
-- 事务开启
START TRANSACTION  -- 标记一个事务的开始
-- 事务操作
-- 提交，持久化
COMMIT 
-- 回滚，回到原来的样子 失败
ROLLBACK
-- 事务结束


SET autocommit = 1    -- 开启自动提交

SAVEPOINT 保存点 -- 设置一个事务的保存点
ROLLBACK TO SAVEPOINT 保存点   -- 回滚到保存点
RELEASE SAVEPOINT 保存点 -- 撤销保存点
```

> 模拟场景

```sql
CREATE TABLE `account`(
	`id` INT(10) NOT NULL AUTO_INCREMENT,
	`name` VARCHAR(30) NOT NULL,
	`money` DECIMAL(9,2) NOT NULL,
	PRIMARY KEY(`id`)
)ENGINE=INNODB  DEFAULT CHARSET=utf8

INSERT INTO account(`name`,`money`) VALUES ('A',2000.00),('B',10000.00)


SET autocommit =0;

START TRANSACTION;

UPDATE account SET money = money-500 WHERE `name` = 'A';
UPDATE account SET money = money+500 WHERE `name` = 'B';

COMMIT;
ROLLBACK;
SET autocommit=-1; 
```

==只要还没有提交，就可以回滚到之前的状态==

### 7、索引

#### 7.1、索引的分类

- 主键索引(PRIMARY KEY)
  - 唯一标识，主键不可重复
- 唯一索引（UNIQUE KEY）
  - 避免重复的列出现，唯一索引可以重复，多个列都可以标识为 唯一索引
- 常规索引(KEY/INDEX)
  - 默认的，index 或key关键字来设置
- 全文索引(FullText)
  - 在特定的数据库引擎下才有
  - 快速定位数据

```sql
-- 增加一个全文索引 索引名(`列名`)
-- primary key 是唯一的，所以不需要索引名
ALTER TABLE student ADD FULLTEXT INDEX `name` (`studentname`);

-- 显示所有的索引信息
SHOW INDEX FROM student;

--  EXPLAIN 分析sql执行的状况
EXPLAIN SELECT * FROM student;
```

#### 7.2、测试索引

```sql
-- 假设100w行数据

select * from app_user where `name` ='用户999'; -- 耗时比较长，需要查询整个表

-- 添加索引 create index 索引名 on 表(字段);
create index id_qpp_user_name ON app_user(`name`);  

select * from app_user where `name` ='用户999'; -- 再查询，只用查一个数据就可以，时间超级短
```

#### 7.3、索引原则

- 索引不是越多越好
- 不要对经常变动的数据加索引
- 小数据量不需要加索引
- 索引一般加在常用来查询的字段上

> 索引的数据结构

hash类型的索引

Btree：INNODB的默认数据结构

阅读文章:http://blog.codinglabs.org/articles/theory-of-mysql-index.html

### 8、权限管理和备份

#### 8.1、用户管理

> SQL yog 可视化管理

![image-20210331205643528](https://xy-picgo.oss-cn-shenzhen.aliyuncs.com/20210331205643.png)

> SQL命令

本质就是操作mysql数据库里的user表

```sql
CREATE USER xuying IDENTIFIED BY '123456';

-- 修改当前用户的密码
SET PASSWORD = PASSWORD('1111')

-- 修改密码（指定用户的）
SET PASSWORD FOR xuying = PASSWORD('111111')

-- 重命名
RENAME USER xuying TO xuying2

-- 用户授权 ALL PRIVILEGES 全部的权限，表.库
-- 几乎所有的都能干，除了给grant(授权的权限)
GRANT ALL PRIVILEGES ON *.* TO xuying2

-- 查询权限
SHOW GRANTS FOR xuying2  -- 查看指定用户的权限
SHOW GRANTS FOR root@localhost  -- 查root要带上后面的@localhost

-- 撤销权限 
REVOKE ALL PRIVILEGES ON *.* FROM xuying2

-- 删除用户
DROP USER xuying2
```

#### 8.2、mysql备份

为什么要备份：

- 保证重要的数据不丢失
- 数据转移

MySQL数据库数据备份的方式

- 直接拷贝物理文件 data文件下

- 在SQL yog这种可视化工具中手动导出

- 使用命令行导出 mysqldump  `cmd`下

  - ```bash
    # mysqldump -h主机 -u用户名 -p密码 数据库 表1 表2 表3>存储位置/文件名
    mysqldump -hlocalhost -uroot -proot school student >D:/a.sql
    
    # 导出数据库
    mysqldump -h主机 -u用户名 -p密码 数据库>存储位置/文件名
    ```

```sql
-- 导入
-- 切换到指定的数据库
-- 这是mysql的登录下
source 数据库备份文件的地址
```



### 9、规范数据库设计

#### 9.1、为什么需要设计

当数据库比较复杂的时候，我们就需要设计了

**糟糕的数据库设计**：

- 数据冗余，浪费空间
- 数据库插入和删除都很麻烦，屏蔽使用物理外键
- 程序的性能差

**良好的数据库设计**：

- 节省内存空间
- 保证数据库的完整性
- 方便我们开发系统

> 软件开发中 ，关于数据库的设计

- 分析需求：分析业务和需要处理的数据库的需求
- 概要设计:设计关系图E-R图

设计数据库的步骤:（个人博客）

- 收集信息，分析需求
  - 用户表(用户登录注销，用户的个人信息，写博客，创建分裂=类)
  - 分类表(文章分类，谁创建的)
  - 文章表(文章的信息)
  - 友链表（）
  - 自定义表（系统信息，某个关键的字，或者一些主字段） key:value
- 标识实体（把需求落地到每个字段）
  - 狂神视频里有表
- 标识实体之间的关系
  - 发文章：user-->blog
  - 文章分类：user - >category
  - 关注：user ->user
  - 评论：user-> user - blog

#### 9.2、三大范式

> 为什么需要数据规范化？

- 信息重复
- 更新异常
- 插入异常
  - 无法正常显示信息
- 删除信息
  - 丢失有效的信息



> 三大范式

**第一范式**(1NF)：数据库的每列都是不可分割的原子数据项

**第二范式**：

- 满足第一范式
- 

![image-20210401101954689](https://xy-picgo.oss-cn-shenzhen.aliyuncs.com/20210401101954.png)

![image-20210401102106543](https://xy-picgo.oss-cn-shenzhen.aliyuncs.com/20210401102106.png)

### 10、JDBC（重点）

#### 10.1、JDBC

SUN公司为了简化开发人员的(对数据库的统一)操作，提供了一个(java操作数据库的)规范，俗称JDBC

![image-20210401104328171](https://xy-picgo.oss-cn-shenzhen.aliyuncs.com/20210401104328.png)

#### 10.2 第一个jdbc程序

```java
import java.sql.*;

public class TestConnecttor {
    public static void main(String[] args) throws SQLException, ClassNotFoundException {
        //1.加载驱动
        Class.forName("com.mysql.cj.jdbc.Driver");  //固定写法，加载驱动

        //2.连接信息
        String url = "jdbc:mysql://localhost:3306/school?" +
                "serverTimezone=UTC&useUnicode=true&characterEncoding=utf8&useSSL=true";
        String userName = "root";
        String pwd = "root";
        
        //3.连接成功，返回数据库对象
        Connection connection = DriverManager.getConnection(url, userName, pwd);
        //  4.执行SQL对象
        Statement statement = connection.createStatement();
	    // 5.执行SQL的对象去执行SQL
        String sql = "select * from student";
        ResultSet resultSet = statement.executeQuery(sql);

        while (resultSet.next()){
            System.out.print("id="+resultSet.getObject("studentno")+"\t");
            System.out.print("name="+resultSet.getObject("studentname")+"\n");
      }

        // 6.释放连接
        connection.close();
    }
}
```

步骤：

1.加载驱动

2.连接信息

3.连接成功，返回数据库对象

4.执行SQL对象

5.执行SQL的对象去执行SQL

6.释放连接



>DriverManager

```java
//1.加载驱动
// 直接去看这个源码就知道怎么回事了，里面有个静态代码块，执行了注册的操作
// DriverManager.registerDriver(new Driver());
Class.forName("com.mysql.cj.jdbc.Driver");  //固定写法加载驱动


//源码
public class Driver extends NonRegisteringDriver implements java.sql.Driver {
    public Driver() throws SQLException {
    }

    static {
        try {
            DriverManager.registerDriver(new Driver());
        } catch (SQLException var1) {
            throw new RuntimeException("Can't register driver!");
        }
    }
}
```

> URL

```java
String url = "jdbc:mysql://localhost:3306/school?" +
                "serverTimezone=UTC&useUnicode=true&characterEncoding=utf8&useSSL=true";
// mysql：3306
// jdbc:mysql://主机地址:端口号/数据库名?参数1&参数2&...

// oracle
// jdbc:oracle:thin:@主机地址:端口号:
```

> connection

```java
Connection connection = DriverManager.getConnection(url, userName, pwd);
// connection 代表数据库
```

> Statement、prepareStatement 执行SQL的对象

```java
Statement statement = connection.createStatement();
// 执行类

// String sql = "SQL的语言"
statement.executeQuery(sql);    // 查询操作，返回ResultSet
statement.executeUpdate(sql);   // 更新、插入、删除。都是这个，返回受影响的行数
statement.execute(sql);    	    // 执行任何SQL
        
```

> ResultSet 查询的结果集，封装了所有的查询结果

获得指定的数据类型

```java
resultSet.getObject();  // 在不知道列类型的情况下使用
// 知道列类型的就可以使用指定的类型
resultSet.getString();
resultSet.getInt();
```

![image-20210402100842806](https://xy-picgo.oss-cn-shenzhen.aliyuncs.com/20210402100842.png)

> 释放资源

```java
// 一定要做，可以封装成一个方法
resultSet.close();
statement.close();
connection.close();
```

> Statement对象不安全
>
> SQL 注入的问题

or '1=1' ，因为SQL的语句是拼接的

#### 10.3、prepareStatement对象

prepareStatement可以防止SQL注入，并且效率更高

```java
statement = connector.prepareStatement(sql);
            statement.setInt(1,67);  //这里的1代表占位符的第一个位置
            statement.setString(2,"ksao");

// 这里第一个date 是 sql.Date 数据库里的Date类型
// 第二个date是util.date  getTime（）获得时间戳
statement.setDate(3,new java.sql.Date(new Date().getTime()));
statement.executeUpdate();
```

#### 10.4、事务

```java
try {
    connector = JdbcUtils.getConnector();
    
    
    connector.setAutoCommit(false);
    //   执行的sql  xxxxx
    connector.commit();
  
}catch (Exception e){
    // 执行失败就回滚
    connector.rollback();
    e.printStackTrace();
}finally {
    JdbcUtils.release(connector,statement,resultSet);
}
```

### 11.



## Redis

### 1、为什么用Nosql

我们现在处于大数据时代，一般的数据库无法分析处理

### 2、发展

数据库

- 早些年MyISAM  ：表锁，十分影响效率，高并发下就会出现严重的锁问题
- Innodb  ：行锁
- 分库分表：来解决写的压力
- 集群解决那个年代的需求

当今的年代：数据量很多，变化块。博客，图片，大文件多，关系型数据库效率很低。需要用一种数据库来专门处理这种数据。这样mysql压力就小很多。所以现在的互联网项目都是很多个数据库一起使用的。

### 3、什么是NoSQL

 Not Only SQL   ，非关系型数据库。

> NoSQL 特点

1. 方便扩展（数据之间没有关系，很好扩展）
2. 大数据量高性能（redis一秒写8w次，读取11w次）
3. 数据类型是多样型的（不需要事先设计数据库，随取随用）

> 比较

```
传统的RDBMS
-结构化组织
-SQL
-数据和关系都存在单独的表中
-数据定义语言
-严格的一致性
-基础的事务....

Nosql
-不仅仅市数据
-没有固定的查询语言
-键值对存储，列存储，文档存储，图形数据库
-最终一致性
-CAP定理和BASE      （进阶）
-高性能，高可用，高可扩
...
```

>  3v和3高

![image-20200628095931709](C:\Users\xuying\AppData\Roaming\Typora\typora-user-images\image-20200628095931709.png)

>各种需求对应的数据库

```
#商品的基本信息  ：  mysql
#商品的描述： 评论：MongoDB
#图片	：
	分布式文件系统：  FastDFS
	淘宝自己的        TFS
	Google			GFS
	HAdoop			HDFS
	阿里云			oss

#商品的关键字（搜索）
	- 搜索引擎  ：solr   elasticsearch
	-ISerach   ：多隆
	
#商品热门的波段信息
 	-内存数据库
 	-Redis  Tair，Memache
#商品的交易，外部的支付接口
	-三方应用
```

> NoSQL 的四大分类

**KV键值对**：

- 新浪：Redis
- 美团：Redis+Tair
- 阿里，百度：Redis+memecache

**文档型数据库（bson格式**）：

- MongoDB
  - 基于分布式文件存储的数据库，c++编写，主要用来处理大量的文档
  - 介于关系型和非关系型数据库中间的产品
- ConthDB

**列存储数据库：**

- HBase
- 分布式文件系统

**图关系数据库**：

- Neo4j，InfoGrid
- 不是存图形，而是放的关系，比如：朋友圈社交网络

> 对比

![image-20200628101056424](C:\Users\xuying\AppData\Roaming\Typora\typora-user-images\image-20200628101056424.png)

### 4、Redis入门

#### 1、概述

> Redis 是什么

Remote Dictionary Server  远程字典服务

redis会周期性的把更新的数据写入磁盘，或者把修改操作写入追加的记录文件，并在此基础上实现了主从同步

> Redis能干嘛？

1、内存存储，持久化（rdb，aof）

2、可以用于高速缓存，效率高

3、发布订阅系统

4、地图信息分析

5、计时器，浏览量

> 特性

1、多样的数据类型

2、持久化

3、集群

4、事务

#### 2、Linux安装

1、下载安装包，解压

2、进入解压后的文件，可以看到redis的配置文件

![image-20210621184253618](https://xy-picgo.oss-cn-shenzhen.aliyuncs.com/20210621184253.png)

3、基本环境安装

```bash
yum install gcc-c++
make 
```

==报错==

因为redis的版本太高，gcc的版本比较低，所以升级一下

```bash
#查看gcc的版本是否在 5.3以上，centos7默认是4.8.5.我这里的就是4.8.5
gcc -v
#升级到 5.3及以上版本
yum -y install centos-release-scl
yum -y install devtoolset-9-gcc devtoolset-9-gcc-c++ devtoolset-9-binutils

scl enable devtoolset-9 bash

echo "source /opt/rh/devtoolset-9/enable" >>/etc/profile

#重启一下
```

```bash
make install #确认一下
```

4、默认的路径  `usr/local/bin`

5、修改配置文件

![image-20210621184300479](https://xy-picgo.oss-cn-shenzhen.aliyuncs.com/20210621184300.png)

6、启动

```
redis-server config/redis.config
redis-cli -p 6379  			#连接

shutdown					#关闭Redis服务
```



#### 3、测试性能

```bash
#测试100个并发连接，100000的请求
redis-benchmark -h localhost -p 6379 -c 100 -n 100000
```

![image-20210622095326835](https://xy-picgo.oss-cn-shenzhen.aliyuncs.com/20210622095326.png)

#### 4、基础知识

redis默认有16个数据库，默认使用的是第0个数据库

```bash
#有16个数据库

127.0.0.1:6379> SELECT 3           #切换数据库
OK
127.0.0.1:6379[3]> flushall		  #清空全部数据库
OK
127.0.0.1:6379[3]> dbsize		  #数据库里面的数据数量
(integer) 0
127.0.0.1:6379[3]> keys *		  #查看所有的key
(empty array)

flushdb 	 					#清空当前数据库

```



> redis为什么单线程还这么快

redis是将所有的数据都放入内存中的，所以说使用你单线程区操作效率是最高的，

因为多线程（cpu上下文会切换：耗时），对于内存系统来说，没有上下文切换效率就是最高的。多次读写都是在一个cpu上，这是最佳的方案

 ==redis是单线程，内存影响它的速度==

### 5、五大数据类型

####  1、Redis-Key

```bash
keys *   				#显示所有的key
set  keyname  xx   		
get  keyname
exists    keyname  		#key是否存在
move keyname number  	#把key移动到 number数据库
expire  keyname  number #设置key 的过期时间   ，单位是秒
ttl keyname   			#查看当前key的剩余时间

type key  #查看当前key的类型

127.0.0.1:6379[3]> keys *
(empty array)
127.0.0.1:6379[3]> set name xuying
OK
127.0.0.1:6379[3]> keys *
1) "name"
127.0.0.1:6379[3]> set age 1
OK
127.0.0.1:6379[3]> keys *
1) "name"
2) "age"
127.0.0.1:6379[3]> EXISTS name
(integer) 1
127.0.0.1:6379[3]> EXISTS na
(integer) 0
127.0.0.1:6379[3]> move name 1
(integer) 1
127.0.0.1:6379[3]> keys *
1) "age"

127.0.0.1:6379[3]> expire age 10
(integer) 1
127.0.0.1:6379[3]> ttl age
(integer) 5
127.0.0.1:6379[3]> get age
"1"
127.0.0.1:6379[3]> ttl age
(integer) -2 			#已经过期
127.0.0.1:6379[3]> get age
(nil)
```

#### 2、String

```bash
append keyname "xxx"  	#在后面追加xx，如果key不存在，就是新建
strlen  key             #获取字符串的长度
incr  key               #加1
decr  key				#减1
incrby key number       #加number
decrby key number       #减number
getrange key 0 3   		#截取 0-3  [0,3]   0 ,-1  是获取全部的
setrange   key 1  xx	#替换制定位置开始的字符串


setex key 10 xxx 		#设置值和过期时间
setnx mykey "test1"      #如果mykey不存在就创建，如果存在就失败,set key 的话就会直接更新值，这里不行



# 加上m表示多个，里面是原子性的操作
mset k1 v1 k2 v2 k3 v3   #设置多个key
mget k1 k2 k3   		 #获取多个key的值

msetnx  k1 v1 k4 v4  	 #是原子性的操作，要成功必须都成功，否则都失败

#创建一个对象
set user:1 {name:xuying,age:3}				#json对象存储
mset user:1:name xuying  user:1:age 10

#组合命令
getset  key  xxxx   #先get再set   ，如果不存在就获得nil，再创建新值

127.0.0.1:6379[3]> set k2 v2
OK
127.0.0.1:6379[3]> get k2
"v2"
127.0.0.1:6379[3]> keys *
1) "k1"
2) "k2"
127.0.0.1:6379[3]> EXISTS k1
(integer) 1
127.0.0.1:6379[3]> append k1 "hello"
(integer) 7
127.0.0.1:6379[3]> get k1
"v1hello"
127.0.0.1:6379[3]> STRLEN k1
(integer) 7

127.0.0.1:6379> set views 0
OK
127.0.0.1:6379> incr views
(integer) 1
127.0.0.1:6379> get views
"1"
127.0.0.1:6379> decr views
(integer) 0
127.0.0.1:6379> get views
"0"
127.0.0.1:6379> INCRBY view 10
(integer) 10
127.0.0.1:6379> get views
"0"
127.0.0.1:6379> INCRBY views 10
(integer) 10
127.0.0.1:6379> get views
"10"
127.0.0.1:6379> get view
"10"
127.0.0.1:6379> get v1
(nil)
127.0.0.1:6379> set v1 "hello,world"
OK
127.0.0.1:6379> GETRANGE v1 0 3
"hell"
127.0.0.1:6379> GETRANGE v1 0 -1
"hello,world"
127.0.0.1:6379> SETRANGE v1 5 xuying
(integer) 11
127.0.0.1:6379> get v1
"helloxuying"


127.0.0.1:6379> setex v2 10 test
OK
127.0.0.1:6379> get v2
"test"
127.0.0.1:6379> ttl v2
(integer) 4
127.0.0.1:6379> setnx v1 hello
(integer) 0
127.0.0.1:6379> get v1
"helloxuying"
127.0.0.1:6379> setnx v3 helo
(integer) 1
127.0.0.1:6379> get v3
"helo"
127.0.0.1:6379> mset q1 h1 q2 h2 q3 h3
OK
127.0.0.1:6379> mget q1 q2 q3
1) "h1"
2) "h2"
3) "h3"
127.0.0.1:6379> getset db
(error) ERR wrong number of arguments for 'getset' command
127.0.0.1:6379> getset db test
(nil)
127.0.0.1:6379> get db
"test"
127.0.0.1:6379> getset db change
"test"
127.0.0.1:6379> get db
"change"
```

#### 3、List

list 可以弄成`队列，双向队列`，`栈`

双向队列

消息队列（lpush Rpop） 栈（lpush  lpop）

```bash
lpush list xxx           #左边插入
rpush list  xxx			#右边插入
lrange list 0 -1      #所有的值,这里是倒着输出的。
lpop
rpop 
lindex key number    	#左边的第number+1的值
Llen  key				#key的长度

lrem key number value 	# LREM list 1 three  移除list里面的 three  （1代表只移除一个）

ltrim key start end    # 截取，只保留[start，end]


RPOPLPUSH key  newKey   #组合命令，弹出之后将其他的放进新list里面

lset key index xxx    #修改index位置的值，如果不存在值就会报错

linsert key after xxx newXXX  #在xx的后面插入newXXX
linsert key before xxx newXXX  #在xx的前面插入newXXX
```

> 小结

实际上是个链表。双向链表 -left - right都可以插入值

- 如果移除了所有值，就是空链表，也代表不存在
- 插入效率高，查找慢

#### 4、Set

无序不重复集合

```bash
Sadd key xxx
smembers key  		#显示set里的元素
sismember key xx	#是否包含xx
scard key  			#获取set集合中的元素个数
srem key xx  		#移除set里的指定元素
sRandMember  key     #随机抽选出一个元素
srandMember key number #随机抽选出指定元素的个数
spop key   			#随机删除集合中的元素
smove key key2 xxx   #将指定的元素从集合中移动到另一个集合，原集合中数就会删掉

					#差集   -- 共同关注
sdiff key1 key2        #key1 - key1 U key2
sinter  key1 key2      #交集 key1 n key2   -- 共同好友
sunion key1 key2	   #并集 key1 U key2


127.0.0.1:6379> sadd myset hello
(integer) 1
127.0.0.1:6379> sadd myset world
(integer) 1
127.0.0.1:6379> sadd myset good
(integer) 1
127.0.0.1:6379> SMEMBERS myset
1) "world"
2) "hello"
3) "good"
127.0.0.1:6379> SISMEMBER myset hello
(integer) 1
127.0.0.1:6379> SISMEMBER myset test
(integer) 0
127.0.0.1:6379> SCARD myset
(integer) 3
127.0.0.1:6379> srem myset hello
(integer) 1
127.0.0.1:6379> SMEMBERS myset
1) "world"
2) "good"
127.0.0.1:6379> SRANDMEMBER myset
"world"
127.0.0.1:6379> SRANDMEMBER myset
"good"
127.0.0.1:6379> SRANDMEMBER myset 2
1) "world"
2) "good"
127.0.0.1:6379> SMEMBERS myset
1) "world"
2) "good"
127.0.0.1:6379> spop myset
"world"
127.0.0.1:6379> SMEMBERS myset
1) "good"
127.0.0.1:6379> sadd myset name
(integer) 1
127.0.0.1:6379> sadd myset2 hi
(integer) 1
127.0.0.1:6379> SMOVE myset myset2 name
(integer) 1
127.0.0.1:6379> SMEMBERS myset2
1) "hi"
2) "name"
127.0.0.1:6379> SMEMBERS myset
1) "good"

127.0.0.1:6379> sadd k1 1
(integer) 1
127.0.0.1:6379> sadd k1 2
(integer) 1
127.0.0.1:6379> sadd k1 3
(integer) 1
127.0.0.1:6379> sadd k1 4
(integer) 1
127.0.0.1:6379> sadd k2 3
(integer) 1
127.0.0.1:6379> sadd k2 4
(integer) 1
127.0.0.1:6379> sadd k2 5
(integer) 1
127.0.0.1:6379> sadd k2 6
(integer) 1
127.0.0.1:6379> SDIFF k1 k2
1) "1"
2) "2"
127.0.0.1:6379> SINTER k1 k2
1) "3"
2) "4"
127.0.0.1:6379> SUNION k1 k2
1) "1"
2) "2"
3) "3"
4) "4"
5) "5"
6) "6"

```

微博，A用户将所有关注的人放在一个set集合中，他的粉丝放在一个集合中。共同关注，共同爱好，二度好友。

#### 5、Hash

Map集合 ，key-map

```bash
#操作和string很像，，在前面加上hxxx就是对hash的操作


hset key xxx(key) xxx2(value)
hget key xxx(key)
hmset  xxxx				#添加多个值
hmget  key  xxx xxx xxx   	#带m的就是可以多个
hgetall  key 				#获取全部值
hdel key xxx				#删除指定的字段，对应的value也被删除
hlen  key 					#获取hash表中的key的数量

hexists key xx(key) 		#key是否存在


#获取hash里的所有key或者值
hkeys key
hvals key    

#自增  incr  自减 decr
hincreby key xx(key)  xx(加的数字)    #+1
hsetnx key xx(key) xx(value)		#如果不存在可以设置，存在就不能设置

```

对象用hash存更方便

#### 6、Zset（有序集合）

在set 的基础上，增加了一个值

```bash
zadd key index（或者值） xxx       #在指定的下标下添加  可以添加多个值
ZRANGEBYSCORE key  -inf +inf      #inf表示无穷大，这个是排序，从小到大，也可以自己输入数值，在区间内的[index1,index2]

zrem key xxx   					#移除xxx
zcard key 						#获取有序集合中的个数
	
zrevrange  key 0 -1       		#从大到小排序

zcount key number1 number2   	#获取(number1,number2)之间的数量
```

### 6、三种特殊数据类型

#### 1 geospatial地理位置

```bash
#无法直接添加南北极

geoAdd key 经度 维度  城市名 #

geopos key 城市名    			#获取指定城市的经纬度

geodist key 城市名1 城市名2   m/km/..  #获取两个城市的距离

georadius key 经度 维度  number  m/km  # 在这个地址的画圈，半径为number里的地址 

geohash key 城市名   				#将城市的经纬度转化为一维的hash值，两个hash越接近城市就越近
```

#### 2 Hyperloglog 

做页面统计之类的。不过有错误率，所以需要容错的才行

优点：占用的内存是固定的，只需要12kb内存，能够存放2

```bash
127.0.0.1:6379> PFADD my a b c d e f      #存放
(integer) 1			
127.0.0.1:6379> PFCOUNT my				#统计数量
(integer) 6
127.0.0.1:6379> pfadd my2 1 2 3 4 6
(integer) 1
127.0.0.1:6379> PFMERGE my3 my my2		#合并成my3
OK
127.0.0.1:6379> PFCOUNT my3
(integer) 11

```

#### 3、Bitmap

> 位存储

统计用户信息，活跃，打卡

```bash
SETBIT key  xx 1(值，只有0  1)     
getbit key  xx
bitcount key    		#统计值为1的数量
```

### 7、事务

redis单条命令是保证原子性的，但是**redis事务不保证原子性**

一次性、顺序性、排他性。

redis事务没有隔离级别的概念，不存在那些问题(各种读)。

所有的命令在事务中，并没有直接执行，只有发起执行命令的时候才会执行

redis的事务：

- 开启事务（multi）
- 命令入队 (...)
- 执行事务(exec)

> 正常执行事务

```bash
127.0.0.1:6379> multi   			#开启事务
OK
127.0.0.1:6379> set k1 v1
QUEUED
127.0.0.1:6379> set k2 v2
QUEUED
127.0.0.1:6379> get k2
QUEUED
127.0.0.1:6379> exec				#执行事务
1) OK
2) OK
3) "v2"
#最后一个错误了，前面的还是会执行
```

> 放弃事务

```bash
127.0.0.1:6379> MULTI
OK
127.0.0.1:6379> set k1 v1
QUEUED
127.0.0.1:6379> set k2 v2
QUEUED
127.0.0.1:6379> set k4 v4
QUEUED
127.0.0.1:6379> DISCARD				#取消事务，事务中的命令都不会执行
OK
127.0.0.1:6379> get k4
(nil)
```

> 编译型异常（代码有问题），事务中所有命令都不执行

在输入命令的时候就已经提示错误，执行事务时会报错

![image-20210623140804203](https://xy-picgo.oss-cn-shenzhen.aliyuncs.com/20210623140804.png)

>运行时异常，错误命令会抛出异常，其他命令还是会执行

![image-20210623141113977](https://xy-picgo.oss-cn-shenzhen.aliyuncs.com/20210623141114.png)

> 监控- 乐观锁

**悲观锁**：

- 认为什么时候都会出问题，无论做什么都会加锁

**乐观锁**：

- 认为什么时候都不会出问题，不上锁。更新数据的时候去判断一下，看在此期间是否有人修改过这个数据。

加锁（乐观锁）

下面的watch相当于把这个值取出来，然后再进行操作的时候，和现在的值进行比较，如果值被改变就无法操作

`正常执行成功`

```cmd
127.0.0.1:6379> set money 100
OK
127.0.0.1:6379> set out 0
OK
127.0.0.1:6379> watch money
OK
127.0.0.1:6379> MULTI
OK
127.0.0.1:6379(TX)> DECRBY money 20
QUEUED
127.0.0.1:6379(TX)> INCRBY out 20
QUEUED
127.0.0.1:6379(TX)> exec
1) (integer) 80
2) (integer) 20

```

`执行错误的情况`

```bash
---- #线程1
127.0.0.1:6379> watch money            #监视money
OK 
127.0.0.1:6379> multi				
OK
127.0.0.1:6379> INCRBY money 10		
QUEUED

--- #此时线程2进来，修改了money

127.0.0.1:6379> get money
"80"
127.0.0.1:6379> set money 1000
OK
127.0.0.1:6379>


---#线程1执行事务
127.0.0.1:6379> exec					#另一个线程改变了money，执行失败
(nil)

unwatch  							#放弃监视，解锁
watch   money						#重新获取最新的值，加锁
```

### 8、jedis

1. 导入依赖

   ```xml
    <!-- https://mvnrepository.com/artifact/redis.clients/jedis -->
   <dependency>
       <groupId>redis.clients</groupId>
       <artifactId>jedis</artifactId>
       <version>3.3.0</version>
   </dependency>
   
   <!-- https://mvnrepository.com/artifact/com.alibaba/fastjson -->
   <dependency>
       <groupId>com.alibaba</groupId>
       <artifactId>fastjson</artifactId>
       <version>1.2.71</version>
   </dependency>
   ```

2. 链接数据库

   `Jedis jedis = new Jedis("127.0.0.1",6379);`

3. 测试链接

   `System.out.println(jedis.ping());`

### 9、springboot整合redis

  springboot2.x之后，`jedis`被替换成了`lettuce`

jedis:采用的直连，多个线程操作的话是不安全的，如果想要避免不安全的，要使用连接池

lettuce：采用netty。实例可以在多个线程中进行共享，不存在线程不安全的情况

> 测试链接

```java
@Autowired
private RedisTemplate redisTemplate;

@Test
void contextLoads() {
    
    //opsForxxx    forvalue 是操作字符串，其他的以看就知道了
    ValueOperations redisString = redisTemplate.opsForValue();
    
    //获取redis的连接对象
    RedisConnection connection = redisTemplate.getConnectionFactory().getConnection();
        connection.flushDb();
}
```

### 10、Redis.comfig



```bash
protected-mode yes				#保护模式
```

> 通用

```bash
daemonize yes					#开启，默认是no，需要自己开启为yes

pidfile /var/run/redis_6379.pid   #如果以后台方式运行，就指定一个id



# Specify the server verbosity level.
# This can be one of:
# debug (a lot of information, useful for development/testing)
# verbose (many rarely useful info, but not a mess like the debug level)
# notice (moderately verbose, what you want in production probably)    生产环境
# warning (only very imze yes
# portant / critical messages are logged)
loglevel notice
```

> 持久化

```bash
save 900 1    # 900s内，如果有一个key进行了修改，就进行持久化操作
save 300 10    #300s内，如果有10个key进行修改,就。。。
save 60 10000

stop-writes-on-bgsave-error yes    #持久化出错，是否需要继续工作

rdbcompression yes      	#是否压缩rdb文件，需要消耗一些cpu资源

rdbchecksum yes				#保存rdb文件，进行错误校验


dbfilename dump.rdb # 持久化保存的文件
dir ./  #持久化文件保存的目录
```

> 安全

设置密码

```bash
127.0.0.1:6379> config get requirepass
1) "requirepass"
2) ""

127.0.0.1:6379> CONFIG SET requirepass 123456
OK
127.0.0.1:6379> config get requirepass
1) "requirepass"
2) "123456"
127.0.0.1:6379> ping
PONG
127.0.0.1:6379> exit
[root@iz2ze46byjjeib649ora99z ~]# redis-cli
127.0.0.1:6379> ping
(error) NOAUTH Authentication required.
127.0.0.1:6379> AUTH 123456
OK
127.0.0.1:6379> ping
PONG
```

> aof

```bash
appendonly no   #默认不开启，默认rdb保存的
appendfilename "appendonly.aof"    #持久化文件的名字

# appendfsync always	#每次修改都会同步，消耗性能，速度慢
appendfsync everysec     #可能会丢失这一秒的数据
# appendfsync no		#不执行同步，操作系统自己同步数据，速度最快
```

### 11、Redis持久化

#### 1.RDB（redis,dataBase）

默认的是RDB。

redis会创建(fork)一个子进程来备份进行I/O操作

缺点：最后一次持久化的数据可能丢失。



> 触发机制

- save的规则满足情况下，会自动触发
- 执行flushall，也会
- 退出redis，也会产生dump.rdb

>

优点：

- 适合大规模的数据恢复！
- 对数据的完整性要求不高。

缺点：

- 需要一定的时间间隔进行操作
- redis宕机了，最后一次修改数据没有了
- fork进程的，会占用一定的内存空间



#### 2.AOF(Append only file)

相当了一个日志



将我们所有的命令都记录下来。恢复的时候，就把这些命令全部执行一遍

只记录写的操作，(读的不记录)。





开启之后，重启就可以生效了



### 12、Redis发布订阅

消息通信模式：发送者发送消息，订阅者接收消息。

![image-20210625094859450](https://xy-picgo.oss-cn-shenzhen.aliyuncs.com/20210625094859.png)



> 命令

![image-20210625095014610](https://xy-picgo.oss-cn-shenzhen.aliyuncs.com/20210625095014.png)

> 测试

```bash
#订阅者
127.0.0.1:6379> SUBSCRIBE xuying
Reading messages... (press Ctrl-C to quit)
1) "subscribe"
2) "xuying"
3) (integer) 1
1) "message"
2) "xuying"
3) "nihao"
1) "message"
2) "xuying"
3) "how are you"


#发布者
127.0.0.1:6379> PUBLISH xuying nihao
(integer) 1
127.0.0.1:6379> PUBLISH xuying  "how are you"
(integer) 1

```

> 原理

![image-20210625095518148](https://xy-picgo.oss-cn-shenzhen.aliyuncs.com/20210625095518.png)

![image-20210625095647940](https://xy-picgo.oss-cn-shenzhen.aliyuncs.com/20210625095648.png)

![image-20210625095916174](https://xy-picgo.oss-cn-shenzhen.aliyuncs.com/20210625095916.png)

### 13、Redis主从复制







#### 环境配置

```bash
127.0.0.1:6379> info replication
# Replication
role:master
connected_slaves:0
master_failover_state:no-failover
master_replid:9dda689162cefe1853ecdd76c90fa76ede20d30d
master_replid2:0000000000000000000000000000000000000000
master_repl_offset:0
second_repl_offset:-1
repl_backlog_active:0
repl_backlog_size:1048576
repl_backlog_first_byte_offset:0
repl_backlog_histlen:0
```





一主二从

·6380当主机·





主机断开了，从机还是从机，就是没有写操作了。

等主机恢复了，主机重新连接，写的数据，从机还能读到



### 14、缓存穿透和雪崩

#### 1.缓存穿透(差不到)

> 概念

查一个数据，先去缓存看，没找到，去数据看也没找到。如果用户很多，同时都查没有的数据，那么就给持久层的数据库造成很大的压力，就出现了缓存穿透(数据库崩溃)。

> 解决办法

- **布隆过滤器**
- 缓存空对象：查询为空时，加到redis缓存中
  - 问题1：如果空值被缓存，那么就需要更多的空间存储来存储空值(可能会有很多空键)
  - 问题2：即使设置过期时间，会存在缓存层和存储层的数据有一段时间窗口不一致，会对业务的一致性有影响

#### 2.缓存击穿（量太大，缓存过期）



> 解决方案

- 设置热点数据永不过期

- 加互斥锁

  ![image-20210625135722508](https://xy-picgo.oss-cn-shenzhen.aliyuncs.com/20210625135722.png)

#### 3.缓存雪崩



