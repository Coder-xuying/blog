### 1.mysql体系结构和存储引擎

#### 1.1 数据库和实例

- 数据库： 物理操作系统文件或其他形式文件类型的集合，比如可以是MYD、ibd结尾的文件
- 实例：MySQL数据库由后台线程以及一个共享内存区组成。  数据库实例才是真正用于操作数据库文件的。

一个实例对应一个数据库，一个数据库对应一个实例。但是， 在集群情况下可能存在一个数据库被多个数据实例使用的情况。

MySQL被设计为一个单进程多线程架构的数据库，MySQL数据库实例在系统上的表现就是一个进程。 

启动实例时，mysql数据库会读取配置文件，根据配置文件的参数来启动数据库实例。 如果多个配置未见，mysql以读取到的最后一个配置文件的参数为准



#### 1.2 体系结构

![](https://xy-picgo.oss-cn-shenzhen.aliyuncs.com/20211017142704.png)

组成：

- 连接池组件
- 管理服务和工具组件
- sql接口组件
- 查询分析器组件
- 优化器组件
- 缓冲组件
- **插件式存储引擎**  （和其他数据库的区别） 存储引擎是基于表的
- 物理文件

#### 1.3 mysql存储引擎

每个存储引擎有自己的特点，根据具体的应用建立不同存储引擎表。**用户可以根据mysql预定义的存储引擎接口编写自己的存储引擎**



##### 1.3.1 InnoDB引擎

支持事务，设计目标主要面向在线事务处理（OLTP）的应用。

特点：

- 行锁设计
- 支持外键
- 支持类似于Oracle的非锁定读， 默认读操作不产生锁

5.5.8之后是默认的存储引擎



Innodb通过使用MVCC来获得高并发，实现了SQL的4中隔离级别，默认Repeatable。使用next-key locking的策略来避免幻读。 初次之外，还提供插入缓冲，二次写，自适应哈希索引、预读等高性能和高可用的功能。



如果没有指定主键，会自动生成一个6字节的ROWID，作为主键



##### 1.3.2 MyISAM

不支持事务，表锁设计。支持全文索引，主要面向一些OLAP数据库应用。5.5.8以前是默认引擎。 因为用不是所有的应用中都需要事务，比如只是简单的查询。 **MyISAM独特的地方是 它的缓冲池只缓存 索引文件，不缓冲数据文件。**



由MYD和MYI文件组成，MYD存放数据文件，MYI来存放索引文件。并且可以压缩数据文件（赫夫曼编码实现的）。

##### 1.3.3 NDB引擎

集群存储引擎，结构是share nothing的集群结构，可以提供更高的可用性。NDB的特点是数据全部放在内存中（5.1版本开始，可以将非索引数据放在磁盘上），因此主键查找速度很快，是高可用和高性能的集群系统。

但是NDB存储引擎的join操作是在mysql数据库层完成的，不是在引擎层，join操作需要巨大的网络开销，查询很慢。

##### 1.3.4 Memory存储引擎

![image-20211017144110024](https://xy-picgo.oss-cn-shenzhen.aliyuncs.com/20211017144110.png)

#### 1.4 连接mysql

连接mysql是连接进程和mysql实例进行通信，本质上是进程通信。

常见的进程通信方式：

- 管道
- 命名管道
- TCP/IP套接字
- 共享内存
- unix套接字

##### 1.4.1 tcp/ip连接

在mysql数据库在任何平台下都提供的链接方式， 客户端client在一台服务器，mysql实例(server) 在另一台。 通过tcp、ip 进行网络连接



连接实例时，mysql会先检查一张权限视图，判断请求的ip是否允许连接到mysql实例，表名为Mysql 下的user表。



##### 1.4.2 命名管道和共享内存

![image-20211017144850440](https://xy-picgo.oss-cn-shenzhen.aliyuncs.com/20211017144850.png)



##### 1.4.3 UNIX域套接字

在linux和unix下，可以使用UNIX域套接字。 UNIX域套接字并不是一个网络协议，所以client和数据库实例必须在一台服务器上。

![image-20211017145023746](https://xy-picgo.oss-cn-shenzhen.aliyuncs.com/20211017145023.png)



### 2.InnoDB存储引擎

#### 2.0 版本

![image-20211030171452337](https://xy-picgo.oss-cn-shenzhen.aliyuncs.com/20211030171452.png)



mysql5.6 已经升级为InnoDB1.2.x了



#### 2.1 InnoDB 体系结构

![image-20211030170428612](https://xy-picgo.oss-cn-shenzhen.aliyuncs.com/20211030170428.png)

后台线程的主要作用是负责刷新内存池中的数据，保证缓冲池中的内存缓存是最近的数据。此外将已修改的数据文件刷新到磁盘文件，同时保证在数据库发生异常的情况下能恢复正常运行状态。

##### 1. 后台线程

多线程模型，后台有多个不同的后台线程，负责处理不同的任务。

> Master Thread

核心的线程，负责缓冲池中的数据异步刷新到磁盘，保证数据的一致性，包括脏页的刷新、合并插入缓冲、undo页的回收。

> IO Thread

InnoDB使用了大量的AIO来处理IO请求，极大的提高性能。 IO Thread的作用是负责这些IO请求的回调处理。

InnoDB 1.0版本之前共有4个IO Thread，分别是write、read、insert buffer和 log IO thread。在 Linux平台下，IO Thread的数量不能进行调整，但是在 Windows下可以通过参数`innodb_file_io_threads`来增大IO Thread。从InnoDB 1.0.x版本开始，read thread和 write thread分别增大到了4个,使用innodb_read_io_threads 和 innodb_write_io_threads参数进行设置。



> Purge Thread

事务被提交后，其使用的undolog不需要了，Purge Thread来回收已经使用的undo页。

现在支持多个Purge Thread，进一步加快undo也的回收。Purge Thread 需要离散的读取undo，能够利用磁盘的随机读取性能

> Page Cleaner Thread

将之前版本中脏页的刷新操作放入到单独的线程完成。减轻master Thread的工作，和对用户查询线程的阻塞，提高性能。

##### 2 内存

###### 1、缓冲池

CPU和磁盘速度的差异，使用缓冲池技术提高性能。 

缓冲池就是内存上的一块区域，通过内存的速度来弥补磁盘速度较慢对数据库性能的影响。

- 在数据库中进行**读取页的操作**，首先将从磁盘读到的页存放在缓冲池中。下一次再读相同的页时，首先判断该页是否在缓冲池中。若在缓冲池中，称该页在缓冲池中被命中，直接读取该页。否则，读取磁盘上的页。
- 对于数据库中页的**修改操作**，则首先修改在缓冲池中的页，然后再以一定的频率刷新到磁盘上。这里需要注意的是，页从缓冲池刷新回磁盘的操作并不是在每次页发生更新时触发，而是通过checkpoint机制刷新回磁盘。

缓冲池的大小直接影响数据库的性能



**缓冲池缓存的数据页类型有**： 数据页、索引页、undo页、插入缓冲、自适应哈希所以、存储的锁信息、数据字典信息等。

![image-20211030171957877](https://xy-picgo.oss-cn-shenzhen.aliyuncs.com/20211030171957.png)



从InnoDB 1.0.x版本开始，允许有多个缓冲池实例。每个页根据哈希值平均分配到不同缓冲池实例中。这样做的好处是减少数据库内部的资源竞争，增加数据库的并发处理能力



###### 2 LRU list 、Free list 和Flush List

传统的数据库的缓冲池是通过LRU(最近最少使用)算法进行管理的。最频繁使用的 页在LRU列表前端，最少使用的 在尾端。缓冲池不能存放新读取的页时，释放LRU列表的尾端的页。

InnoDB缓冲池页的大小默认是16KB，并且对LRU做了一些修改，在LRU列表中加入了midPoint位置，**新读入的页面放入到midPoint位置(LRU列表长度的5/8处)**。



> 为什么要这样？

​	因为有些SQL的操作(索引或数据的扫描操作)。这类操作需要访问表中的许多页，甚至是全部的页，**而这些页通常来说又仅在这次查询操作中需要**，并不是活跃的热点数据。如果页被放入LRU列表的首部，**那么非常可能将所需要的热点数据页从LRU列表中移除**，而在下一次需要读取该页时，InnoDB存储引擎需要再次访问磁盘。



​	为了解决这个问题，InnoDB存储引擎引人了另一个参数来进一步管理LRU列表，这个参数是innodb_old_blocks_time，用于**表示页读取到mid位置后需要等待多久才会被加入到LRU列表的热端**。



LRU列表用来管理已经读取的页，但当数据库刚启动时，LRU列表是空的，即没有任何的页。**这时页都存放在Free列表中。**当需要从缓冲池中分页时，首先从 Free列表中查找是否有可用的空闲页，若有则将该页从Free列表中删除，放入到LRU列表中。否则，根据LRU算法，淘汰LRU列表末尾的页，将该内存空间分配给新的页。当页从LRU列表的old部分加人到new部分时，称此时发生的操作为page made young，而因为innodb_old_blocks_time的设置而导致页没有从old部分移动到new部分的操作称为page not made young。可以通过命令SHOW ENGINE INNODB STATUS来观察LRU列表及Free列表的使用情况和运行状态。



> 压缩页  - unzip_LRU列表管理

InnoDB存储引擎从1.0.x版本开始支持压缩页的功能，即将原本16KB的页压缩为1KB、2KB、4KB和8KB。而由于页的大小发生了变化，LRU列表也有了些许的改变。对于非16KB的页，是通过unzip_LRU列表进行管理的。

对于压缩页的表，每个表的压缩比率可能各不相同。可能存在有的表页大小为8KB，有的表页大小为2KB的情况。unzip_LRU是怎样从缓冲池中分配内存的呢?



首先，在unzip_LRU列表中对不同压缩页大小的页进行分别管理（其实就是有两种unzip_LRU(分别管理4kb和8kb的页面)和LRU列表）。其次，通过伙伴算法进行内存的分配。例如对需要从缓冲池中申请页为4KB的大小，其过程如下:

1. 检查4KB的unzip_LRU列表，检查是否有可用的空闲页;
2. 若有，则直接使用;
3. 否则，检查8KB的unzip_LRU 列表;
4. 若能够得到空闲页，将页分成2个4KB页，存放到4KB的unzip_LRU列表;
5. 若不能得到空闲页，从LRU列表中申请一个16KB的页，将页分为1个8KB的页、2个4KB的页，**分别存放到对应的unzip_LRU列表中。**



> 脏页  - flush列表管理

​	在LRU列表中的页被修改后，称该页为脏页(dirty page)，即**缓冲池中的页和磁盘上的页的数据产生了不一致**。这时数据库会通过**CHECKPOINT机制将脏页刷新回磁盘**，而**Flush列表中的页即为脏页列表**。需要注意的是，**脏页既存在于LRU列表中，也存在于Flush列表中**。LRU列表用来管理缓冲池中页的可用性，Flush列表用来管理将页刷新回磁盘，二者互不影响。



###### 3.重做日志缓冲 

**redo log buffer**

​	InnoDB存储引擎的内存区域除了有缓冲池外，还有重做日志缓冲(redo log buffer)。InnoDB存储引擎首先将重做日志信息先放入到这个缓冲区，然后按一定频率将其刷新到重做日志文件。重做日志缓冲一般不需要设置得很大,一般情况下每一秒钟会将重做日志缓冲刷新到日志文件，因此用户只需要保证每秒产生的事务量在这个缓冲大小之内即可。**默认8M**

> 三种情况下，会将redo log buffer刷新到redo log文件中

- Master Thread每一秒将重做日志缓冲刷新到重做日志文件;
- 每个事务提交时会将重做日志缓冲刷新到重做日志文件;
- 当重做日志缓冲池剩余空间小于1/2时，重做日志缓冲刷新到重做日志文件。

##### 3.checkpoint技术

倘若每次一个页发生变化，就将新页的版本刷新到磁盘，开销很大。若热点数据集中在某几个页中，那么数据库的性能将变得非常差。同时，如果在从缓冲池将页的新版本刷新到磁盘时发生了宕机，那么数据就不能恢复了。为了避免发生数据丢失的问题，当前事务数据库系统普遍都采用了Write Ahead Log策略，即当事务提交时，先写重做日志，再修改页。



因此Checkpoint（检查点）技术的目的是解决以下几个问题:

- 缩短数据库的恢复时间;
- 缓冲池不够用时，将脏页刷新到磁盘;
- 重做日志不可用时，刷新脏页。

数据库宕机之后，不需要重做所有的日志，因为checkpoint之前的已经刷新到磁盘了。只用对后面的日志进行恢复。

当缓冲池不够用时，根据LRU算法会溢出最近最少使用的页，若此页为脏页，那么需要强制执行Checkpoint，将脏页也就是页的新版本刷回磁盘。                                                                                                  