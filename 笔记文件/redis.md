# Redis

## 基础

### 常用数据结构和应用场景

#### String

##### 1.基本介绍

String 是最基本的 key-value 结构，value 是具体的值，value其实不仅是字符串， 也可以是数字（整数或浮点数），value 最多可以容纳的数据长度是 `512M`。

SDS（简单动态字符串）：

- **SDS 不仅可以保存文本数据，还可以保存二进制数据**。
  -  SDS使用len属性来判断字符串是否结束
  -  SDS 的所有 API 都会以处理二进制的方式来处理 SDS 存放在 `buf[]` 数组里的数据。
- **SDS 获取字符串长度的时间复杂度是 O(1)**
- **Redis 的 SDS API 是安全的，拼接字符串不会造成缓冲区溢出**。
  - 因为 SDS 在拼接字符串之前会检查 SDS 空间是否满足要求，如果空间不够会自动扩容，所以不会导致缓冲区溢出的问题。



##### 2.场景

- 缓存对象：直接缓存整个对象的json
- 计数：计算访问次数、点赞、转发、库存数量等等。
- Setnx 实现分布式锁
  - 参考文章：http://kaito-kidd.com/2021/06/08/is-redis-distributed-lock-really-safe/ 后面还有些深入的暂时没看
  - Setnx+过期时间（以前还需要考虑原子性，现在redis自己放进一个命令去了），问题：**客户1加锁成功，锁住了，执行时间超时，此时客户2进来加锁成功，客户1执行完毕，会删除客户2的锁**
  - 为了解决上面的问题，控制过期时间（网络复杂，这块并不能完成解决）。设置value唯一标识，比如uuid，在解锁的时候比较一下，看看是不是自己的锁。（get(key)==value ,del key）。设计到原子性的问题，可以把命令封装到lua脚本中执行
  - 控制过期时间，冗余过期时间--**加锁时，先设置一个过期时间，然后我们开启一个「守护线程」，定时去检测这个锁的失效时间，如果锁快要过期了，操作共享资源还未完成，那么就自动对锁进行「续期」，重新设置过期时间。** -- **Redisson**的做法
  - 通常使用Redis会做集群（主从切换的话，分布式锁就有问题）。Redlock提出来解决-- 
- 共享session的信息
  - 用session来保存用户的会话（登录状态），session会被 保存在服务端



#### LIST

##### 1.基本介绍

List 类型的底层数据结构是由**双向链表或压缩列表**实现的：

- 如果列表的元素个数小于 `512` 个，列表每个元素的值都小于 `64` 字节，使用压缩列表
- 否则使用双向链表
- 3.2版本之后，只使用quicklist作为底层实现（可以理解为是上面两个的结合体）

##### 2.应用场景

- 消息队列
  - List 可以使用 LPUSH + RPOP （或者反过来，RPUSH+LPOP）命令实现消息队列
    - **问题1**：生产者生产之后并不会通知消费者，消费者必须一直调用RPOP
    - 为了解决这个问题，Redis提供了 BRPOP 命令，**BRPOP命令也称为阻塞式读取，客户端在没有读到队列数据时，自动阻塞，直到有新的数据写入队列，再开始读取新数据**。
    - **问题2**：*如何处理重复的消息？*
    - 每个消息都有一个全局的 ID。 **List 并不会为每个消息生成 ID 号，所以我们需要自行为每个消息生成一个全局唯一ID**
    - 比如：LPUSH mq "全局ID:Message"这样
    - **问题3**：*如何保证消息可靠性？*消费者程序从 List 中读取一条消息后，List 就不会再留存这条消息了。所以，如果消费者程序在处理消息的过程出现了故障或宕机，就会导致消息没有处理完成。
    - List 类型提供了 `BRPOPLPUSH` 命令，这个命令的**作用是让消费者程序从一个 List 中读取消息，同时，Redis 会把这个消息再插入到另一个 List（可以叫作备份 List）留存**。
  - 缺点：
    - **List 不支持多个消费者消费同一条消息**
    - **List 类型并不支持消费组的实现**。



#### 3.Hash

##### 1.基本介绍

Hash 特别适合用于存储对象。Hash 类型的底层数据结构是由**压缩列表或哈希表**实现的：

- 选择同list一样。不过7.0版本
- **压缩列表数据结构已经废弃了，交由 listpack 数据结构来实现了**。



##### 2.场景

- 缓存对象 
- 购物车：
  - 添加商品：`HSET cart:{用户id} {商品id} 1`
  - 添加数量：`HINCRBY cart:{用户id} {商品id} 1`
  - 商品总数：`HLEN cart:{用户id}`
  - 删除商品：`HDEL cart:{用户id} {商品id}`
  - 获取购物车所有商品：`HGETALL cart:{用户id}`



#### 4.Set

##### 1.基本介绍

Set 类型是一个无序并唯一的键值集合，一个集合最多可以存储 `2^32-1` 个元素，可以求交集，并集，差集。

Set 类型的底层数据结构是由**哈希表或整数集合**实现的：

- 如果集合中的元素都是整数且元素个数小于 `512` ，Redis 会使用**整数集合**作为 Set 类型的底层数据结构
- 否则使用hash表

##### 2.应用场景

Set 类型比较适合用来数据去重和保障数据的唯一性，还可以用来统计多个集合的交集、错集和并集。但是**Set 的差集、并集和交集的计算复杂度较高，在数据量较大的情况下，如果直接执行这些计算，会导致 Redis 实例阻塞**。（在主从模式中，通常使用从库完成聚合统计操作）

- 点赞： SADD article:1 uid:1 uid:2 用户1和2都给文章1点赞
- 共同关注
- 抽奖活动

#### 5.Zset

##### 1.基本介绍

Zset 类型（有序集合类型）相比于 Set 类型多了一个排序属性 score（分值）

Zset 类型的底层数据结构是由**压缩列表或跳表**实现的：

- 如果有序集合的元素个数小于 `128` 个，并且每个元素的值小于 `64` 字节时，Redis 会使用**压缩列表**（**Redis 7.0**， **listpack** 替代了压缩列表）
- 否则，Redis 会使用**跳表**作为 Zset 类型的底层数据结构；



##### 2.应用场景

- 排行榜
- 电话排序、姓名排序



#### 6.BitMap

Bitmap，即位图，是一串连续的二进制数组（0和1），可以通过偏移量（offset）定位元素。特别适合一些数据量大且使用**二值统计的场景**。



## 面试题

### 1.认识redis

##### 1.什么是redis

- redis是基于内存的数据库，对数据的读写操作在内存中完成，读写速度非常快，常用做缓存、消息队列、分布式锁
- redis提供了多种数据类型来支持不同的业务场景，比如string、hash、List、set、zset、Bitmaps、hyperLoglog、GEO、Stream，对这些类型的操作都是原子性的，单线程执行，没有并发竞争的问题
- 除此之外，redis还支持事务、持久化、Lua脚本、多种集群方案、发布/订阅、内存淘汰、过期删除等机制

##### 2.Redis和Memcached的区别

- Redis支持更加丰富的数据类型，而Mem只支持key/value
- Redis支持持久化、Mem不支持
- Redis有容灾处理，内存满了会将数据存放在硬盘中，Mem会抛出异常
- Redis有原生的集群模式，Memcached 没有原生的集群模式，需要依靠客户端来实现
- Redsi支持发布订阅、Lua脚本、事务等功能，Mem不支持

##### 3.五种常见的数据类型的实现

- string：String 类型的底层的数据结构实现主要是 SDS（简单动态字符串）
  - SDS不仅可以保存文本数据，还能保留二进制数据。因为SDS用len来判断字符串是否结束而不是空字符，并且SDS的API都会以处理二进制的方式来处理SDS存放在buf[]里的数据
  - SDS获取长度的时间复杂度为O（1）
  - Redis中的SDS API是安全的，拼接字符串不会造成缓冲区溢出。右

### 2、Redis线程模型

##### Redis是单线程吗？

**Redis 单线程指的是「接收客户端请求->解析请求 ->进行数据读写等操作->发送数据给客户端」这个过程是由一个线程（主线程）来完成的**

redis并不是单线程的，在启动的时候，会启动后台线程：

- redis2.6，会启动两个后台线程，分别处理**关闭文件、AOF刷盘**两个操作
- Redis4.0之后，新增一个新的后台线程，用来异步释放redis内存，也就是 lazyfree 线程。
  - 执行 unlink key / flushdb async / flushall async 等命令，会用到上面的线程，不会阻塞主线程
  - 执行大key删除的时候，不要用del，因为 del 是在主线程处理，可以使用 unlink 命令来异步删除大key

因为`关闭文件、AOF刷盘、释放内存`等操作比较耗时，如果用主线程来执行，会导致主线程阻塞。

可以理解为生产者-消费者。生产者创建后台任务，消费者（BIO）去队列里面拿出来处理，这里用到的BIO的轮询机制

- 关闭文件、AOF 刷盘、释放内存这三个任务都有各自的任务队列，消费者不断的从队列取出任务在后台执行。

![image-20221006221400390](/Users/xuying/Library/Application Support/typora-user-images/image-20221006221400390.png)

##### redis的单线程模型

### 3、Redis持久化

#### redis如何实现数据不丢失

redis重启后，内存中数据会丢失，为了保证数据不丢失，需要实现数据持久化的机制，会将数据存储到磁盘中，然后在重启的时候恢复所有的数据

redis有三种持久化方式：

- AOF日志：执行的**写操作命令**，会被追加到一个文件里 （记录命令）
- RDB快照：某一个时刻内存数据，以二进制写入磁盘
- 混合持久化：redis4.0 新增的方式，集成了AOF和RDB的优点

#### AOF

redis**执行完**写操作命令，把追加命令写到文件里，命令追加到aof_buf缓冲区，调用内核态I/O的write()方法，**write方法会把数据拷贝到内核缓冲区**，写磁盘的操作是内核自己决定的（内核会有一个fsync()方法，执行了就会把内核缓冲区数据写入到磁盘中）

> 为什么先执行命令，再数据写入日志

优点：

- **避免额外的检查开销**：命令执行成功了，不需要做语法检查，不会记录错误的命令
- **不会阻塞当前写操作的执行**

缺点：

- **数据可能会丢失**，redis还没将命令写入硬盘，服务器宕机
- **可能会阻塞其他操作：写AOF日志在主线程执行**

##### 写入磁盘策略

先

- Always: 每次写操作执行后，都写入AOF日志写入到磁盘  
  - 每次写入 AOF 文件数据后，就执行 fsync() 函数
  - 优缺点：几乎不会丢数据，对性能影响大
- Everysec：每秒，写操作执行后，先写入aof_buf缓冲区，每隔一秒就将缓冲区ed内容写回到硬盘
  - 创建一个**定时的异步任务**来执行 fsync() 函数
  - 优缺点：性能适中，丢失1s数据
- No：意味着不由 Redis 控制写回硬盘的时机，转交给操作系统控制写回的时机，
  - 每次写操作命令执行完后，先将命令写入到 AOF 文件的内核缓冲区，再**由操作系统决定**何时将缓冲区内容写回硬盘。
  - 优缺点：性能最好，会丢失比较多的数据

##### AOF重写机制

写命令越来越多，AOF日志文件会越来越大，就会有性能问题，比如redis重启后，通过AOF文件恢复数据特别慢，当AOF文件大小超过阈值，就会启动AOF重写，压缩AOF文件

> 简单的理解

在重写时，会读取数据库中的所有键值对，将每个键值对用一条命令记录到新的AOF文件，全部记录完之后，将新的AOF文件替换现有AOF文件

比如：1、set name xiao  2、 set name xu  最后压缩成一个命令set  name xu

> 过程

由后台子进程(***bgrewriteaof\*** )完成的 

- 优点
  - 子进程重写时，主进程可以继续处理命令请求
  - 这里使用子进程，而不是线程，是因为多线程之间会共享内存，修改共享内存需要加锁，降低性能。父子进程则共享内存数据，共享的内存是只读的，
    - 注意，copy on write写的是AOF文件，而不是内存

### 5、Rdis过期策略和内存淘汰策略

#### 过期删除

#### 如何判定key过期了？

对key设置过期时间，redis会把key带上过期时间存储到一个过期字典，它会保存所有key的过期时间。

- 字典key是一个指针，指向某个键对象
- value是long long类型的整数，整数保存了key的过期时间 （过期时间+当前时间计算）

>  如何检查key是否过期

查询过期字典 有无key =》 有key的话看过期时间=》比较过期时间和当前系统时间大小=》 小于则过期



#### 三大过期策略

- 定时删除
  - 设置key过期时间时，设置一个定时任务，时间到达，事件处理器自动执行key的删除操作。
  - 过期key能够比较快的被删除，即内存释放比较快，对内存友好
  - 过期key比较多的情况，删除key会占用cpu的时间，会影响服务器的响应时间和吞吐量，定期删除对CPU不友好
- 惰性删除
  - 每次访问key，检测key是否过期，如果过期就删除该key
  - 每次访问才检查key过期，只会使用少量的系统资源，对CPU时间比较友好
  - 会有内存空间的浪费，如果一直不访问
- 定期删除
  - 每隔一段时间，就取一定数量的key检查，删除其中过期key
  - 减少了对cpu的影响，也删除了部分过期数据
  - 对内存和cpu都没有上面两种策略更优，比较均衡，另外 不太好确定操作执行的时机和频率。

#### redis的过期策略

redis使用惰性删除+定期删除

- redis的惰性删除：访问key的时候，判断是否过期，过期就删除数据（同步和异步两种方式，有个配置），返回null给客户端

- 定期删除

  - 频率：每进行10次过期检查，可以通过配置调整																				
  - 取20个key删除（写死在代码里的），然后看其中**过期key数量是否> 4**, 如果超过就继续重复该过程（超过25% 认为过期key太多，需要多清理点key），此外会有一个时间控制避免循环太多次，这个时间时25ms

  

  

  #### 内存淘汰

  redis使用内存大于分配的内存，需要删除key释放内存

  淘汰策略

- 不淘汰
  - noevcition
- 淘汰
  - 所有数据 voltatile 
    - allkeys- random
    - allkeys-lru
    - allkeys-lfu
  - 过期字典(设置了过期时间的数据) voltatile 
    - random
    - tll 
    - lru
    - lfu

### 4、Redis与MySQL双写一致性如何保证？

##### 一致性

- 强一致性：它要求系统写入什么，读出来的也会是什么
- 弱一致性：尽可能地保证到某个时间级别（比如秒级别）后，数据能够达到一致状态：
- 最终一致性：系统会保证**在一定时间内**，能够达到一个数据一致的状态。（弱一致性的特例）

### 缓存

#### 1.为什么用缓存？

- 高性能，用户经常访问的数据放在缓存中，就能很快访问到
- 高并发，数据库每秒查询的次数大概是1w左右，使用redis之后能达到10w

总结：为了提高用户的体验



#### 2.分布式缓存技术选型

redis和memcached

> 比较

共同点：

- 都是基于内存的数据库，用来做缓存
- 都有过期策略
- 性能高

区别：

- redis是单线程的I/O复用模型(6.0之后引入网络读写多线程I/O)，memcached是多线程的

- redis支持复杂的数据类型，memcached只支持key/value

- redis可以持久化，重启的时候可以再次加载，memcached不行

- redis有容灾机制，redis在服务器内存满了之后，可以将数据放到硬盘里，memcached会在内存用完之后抛出异常

- redis支持事务、lua脚本、发布订阅等功能，memcached不支持

- redis支持原生的集群，memcached依赖客户端实现

- 对过期数据，redis的删除策略有定时删除和惰性删除，memcached只使用了惰性删除

  

#### 3.几种缓存问题

##### 1.缓存穿透

定义： 大量请求的key不在缓存中，直接请求到了数据库，压力过大。

解决办法：

- 参数检验，对不合法的参数抛出异常
- 缓存无效的key，设置过期策略  --- 黑客大量构造无效key，进行攻击
- 布隆过滤器  -- 使用过程：
  - 先将可能存在的请求值都放进布隆过滤器中
  - 用户发起请求，先判断请求的key是否在布隆过滤器中，如果在，就查数据
  - 如果不在，就返回请求参数错误给用户

> 布隆过滤器

![image-20210722161507630](https://xy-picgo.oss-cn-shenzhen.aliyuncs.com/20210722161507.png)

其实就是将一个元素(字符串) ，先通过hash，变成一段01组成的位数组。 然后再位数组里面，将1对应的位置置位1。查询有没有元素在里面，只需要将元素hash，然后判断位数组对应的每个位置是否是1，如果都是1，就说明这个元素存在，否则就是不在。

缺点：

- 存在一定的错误。就是这个数本来不在这里面，但是可能会被误判在里面，因为多个元素的位会组合成新的元素。所以存放的元素越多，误判的概率越大。**但是布隆过滤器说元素不在里面，那肯定就不在**
- 不能删除元素：如果一个元素被删除，但是却不能从布隆过滤器中删除，这也是造成假阳性的原因了

##### 2.缓存雪崩

定义：缓存在同一时间大面积的失效，后面的请求都直接落到了数据库上

解决办法：

- redis集群
- 加互斥锁
- 降速限流，避免同时处理大量的请求
- 过期时间设置随机，防止同一时间大面积过期的现象发生



##### 3.缓存击穿

定义：被大量访问的数据(热点缓存)在某个时间失效了，请求到了数据库上，压力太大

解决办法：

- 缓存永不失效
- 加互斥锁



##### 4.缓存预热

缓存预热就是系统上线后，将相关的缓存数据直接加载到缓存系统，这样就可以避免在用户请求的时候，先查询数据库，然后再将数据回写到缓存。

如果不进行预热， 那么 Redis 初始状态数据为空，系统上线初期，对于高并发的流量，都会访问到数据库中， 对数据库造成流量的压力。

> 操作方法

- 数据量不大的时候，工程启动的时候进行加载缓存动作；
- 数据量大的时候，设置一个定时任务脚本，进行缓存的刷新；
- 数据量太大的时候，优先保证热点数据进行提前加载到缓存。

##### 5.缓存降级

缓存降级是指缓存失效或缓存服务器挂掉的情况下，不去访问数据库，直接返回默认数据或访问服务的内存数据。

在项目实战中**通常会将部分热点数据缓存到服务的内存**中，类似HashMap、Guava这样的工具，一旦缓存出现异常，可以直接使用服务的内存数据，从而避免数据库遭受巨大压力。

当然，这样的操作对于业务是有损害的，分布式系统中很容易就出现数据不一致的问题。



#### 4、redis为什么这么快

- 操作是基于内存的
- IO多路复用，基于epoll/select/kqueue的IO多路复用技术，实现高吞吐的网络IO 。 **linux用的是epoll**
- 单线程模型，避免了多线程频繁上下文切换
- redis内置了多种优化后的数据结构实现，性能非常高

### 事务

#### 1.事务相关的命令

- watch ：  监视指定的kye
- Multi ：   开启一个事务
- unwatch  ：取消watch对所有key的监视
- discard  ： 放弃事务
- exec  ：触发并执行事务中的所有命令



redis事务没有隔离级别的概念。且事务不保证原子性

redis的事务就是使用`multi`开启事务，然后所有的命令就进入一个队列，然后用exec命令，依次执行。

> 事务取消执行

1.可以使用`DISCARD`命令回滚。取消事务

2.编译型异常，命令输入有误，事务里的所有命令都不会执行

==运行时异常，只会让这一个命令失效，其他命令正常执行。比如1/0这种==



#### redis锁

使用watch监控。watch可以看出redis的乐观锁。开启事务之前，先watch一个对象，然后执行过程中，会比较这个对象有没有被修改过。如果被其他线程改过，就会使事务执行失败。

### 持久化

#### 1.RDB(Redis DataBase)

指定的时间间隔，将数据集快照写入磁盘。实际操作过程是fork一个子进程，先将数据集写入临时文件，写入成功后，再替换之前的文件，再二进制压缩存储

优点:

- 容灾性，方便备份
- 性能最大化。fork子进程来写，主进程能够继续处理命令。保证了redis的高性能
- 数据集大的时候，比AOF启动更快

缺点：

- 安全性低。存在时间间隔，如果时间内redis宕机了，那么就丢失数据
- RDB通过fork子进程协助，如果数据集很大的时候，可能会导致整个服务器停止服务几百毫秒甚至1s

> 触发

- 手动触发：save命令，这个是主进程进行RDB持久化操作，会阻塞当前的Redis服务器，知道RDB过程完成，不建议使用
- 自动触发：bgsave方式。一般可以配置多久触发一次，比如xx秒内修改xx次。或者使用shutdown命令，或者从节点全量复制的时候会触发

> bgsave的过程

bgsave是父进程fork出一个子进程进行持久化操作，所以不会影响redis服务器。

![image-20210819111733861](https://xy-picgo.oss-cn-shenzhen.aliyuncs.com/20210819111733.png)

- 执行bgsave命令，Redis父进程判断当前是否存在正在执行的子进程，如果存在，bgsave命令直接返回
- 父进程执行fork操作创建子进程，fork操作过程中父进程会阻塞
- 父进程fork完成后，bgsave命令返回“Background saving started”信息并不再阻塞父进程
- 子进程创建RDB文件，根据父进程内存生成临时快照文件，完成后对原有文件进行原子替换
- 进程发送信号给父进程表示完成，父进程更新统计信息

#### 2.AOF(Append only File)

日志的形式，记录服务器处理的每一个写、删除操作。文本的方式

（1）所有的写入命令会追加到aof_buf（缓冲区）中。

（2）AOF缓冲区根据对应的策略向硬盘做同步操作。

（3）随着AOF文件越来越大，需要定期对AOF文件进行重写，达到压缩的目的。

（4）当Redis服务器重启时，可以加载AOF文件进行数据恢复。

> AOF为什么把命令追加到aof_buf中？

Redis使用单线程响应命令，如果每次写AOF文件命令都直接追加到硬盘，那么性能完全取决于当前硬盘负载。先写入缓冲区aof_buf中，还有另一个好处，Redis可以提供多种缓冲区同步硬盘的策略，在性能和安全性方面做出平衡。



**优点**：

- 数据安全：- 三种同步策略
  - 每秒同步  -- 可能会丢失一秒的数据，redis宕机
  - 每修改同步  --  数据更完整
  - 不同步    -- 效率最高
- append模式写文件，服务器宕机不会破坏已经存在的内容，redis-check-aof可以解决数据一致性的问题
- AOF的rewrite模式，定期对AOF文件重写，压缩--- （**有的命令可以整合**）

> rewrite机制

重写的目的：

- 减小AOF文件占用空间；
- 更小的AOF 文件可以更快地被Redis加载恢复。

AOF重写可以分为手动触发和自动触发：

- 手动触发：直接调用bgrewriteaof命令。
- 自动触发：根据auto-aof-rewrite-min-size和auto-aof-rewrite-percentage参数确定自动触发时机。

**缺点**：

- AOF比RDb大，恢复速度慢
- 启动效率比RDB低
- 运行效率比RDB低，根据同步策略看



`appendonly` 改为yes就开启了 aof！



> Redis4.0支持混合持久化

Redis 4.0 开始支持 RDB 和 AOF 的混合持久化（默认关闭，可以通过配置项` aof-use-rdb-preamble` 开启）。

如果把混合持久化打开，AOF 重写的时候就直接把 RDB 的内容写到 AOF 文件开头。这样做的好处是可以结合 RDB 和 AOF 的优点, 快速加载同时避免丢失过多的数据。当然缺点也是有的， AOF 里面的 RDB 部分是压缩格式不再是 AOF 格式，可读性较差。

**如果AOF和RDB都开启了，优先加载AOF文件**

 数据恢复流程说明：

（1）AOF持久化开启且存在AOF文件时，优先加载AOF文件。

（2）AOF关闭或者AOF文件不存在时，加载RDB文件。

（3）加载AOF/RDB文件成功后，Redis启动成功。

（4）AOF/RDB文件存在错误时，Redis启动失败并打印错误信息。





### 过期时间

#### 1.为什么要设计过期时间

- 缓解内存的消耗
- 某些特定场景需要(验证码等)



#### 2.redis如何判断数据是否过期

redis通过一个过期字典保存数据过期的时间

```c
typedef struct redisDb {
    ...

    dict *dict;     //数据库键空间,保存着数据库中所有键值对
    dict *expires   // 过期字典,保存着键的过期时间
    ...
} redisDb;
```

![image-20210722164654876](https://xy-picgo.oss-cn-shenzhen.aliyuncs.com/20210722164654.png)

#### 3.过期数据的删除策略

**定期删除**：redis默认是每隔100ms就随机抽取一些设置了过期时间的key，检查其是否过期，如果过期就删除。为什么要随机呢?假如redis存了几十万个key，每隔100ms就遍历所有的设置过期时间的key的话，就会给CPU带来很大的负载。

**惰性删除**：定期删除是随机选取key，所以有的key没有被删掉，这样的话，只有你的系统去查一下那个key，才会被redis删除

定期删除对内存更加友好，惰性删除对 CPU 更加友好。于是redis就两者结合起来



但是实际上这还是有问题的，如果定期删除漏掉了很多过期key，然后你也没及时去查，也就没走惰性删除，此时会怎么样？ 　如果大量过期key堆积在内存里，导致redis内存块耗尽了，怎么办？

答案：**走内存淘汰机制。**

#### 4、八种内存淘汰机制

volatile-lru（least recently used）：从设置过期时间的数据集（server.db[i].expires）中挑选最近最少使用的数据，淘汰
volatile-ttl：从设置过期时间的数据集中挑选要过期的数据，淘汰
volatile-random：从已设置过期时间的数据集中任意选择数据淘汰
allkeys-lru（least recently used）：在键空间中移除最近最少使用的key
allkeys-random：数据集中任意淘汰数据
no-eviction：内存不足容纳写入数据时，新写入操作会报错
-- 这两个是4.0后增加的
volatile-lfu（least frequently used）：从已设置过期时间的数据集中挑选最不经常使用的数据淘汰
allkeys-lfu（least frequently used）：当内存不足以容纳新写入数据时，在键空间中，移除最不经常使用的 key



### 线程模型

#### 1、Redis 单线程模型详解  

-- 看一下nio那些，现在不会

#### 2、Redis 没有使用多线程？为什么不使用多线程？

实际上，**Redis 在 4.0 之后的版本中就已经加入了对多线程的支持。** Redis 4.0 增加的多线程主要是针对一些大键值对的删除操作的命令，使用这些命令就会使用主处理之外的其他线程来“异步处理”。

>**Redis6.0 之前 为什么不使用多线程？**

1. 单线程编程容易并且更容易维护；
2. Redis 的性能瓶颈不在 CPU ，主要在内存和网络；
3. 多线程就会存在死锁、线程上下文切换等问题，甚至会影响性能。

> Redis6.0 之后为何引入了多线程？

**Redis6.0 引入多线程主要是为了提高网络 IO 读写性能**，因为这个算是 Redis 中的一个性能瓶颈（Redis 的瓶颈主要受限于内存和网络）。

### 集群

#### 主从复制

是指将一台Redis服务器的数据，复制到其他的Redis服务器。前者称为主节点(master/leader)，后者称为从节点(slave/follower)； **数据的复制是单向的**，只能由主节点到从节点。

主从复制的作用：

- 数据冗余：主从复制实现了数据的热备份，是持久化之外的一种数据冗余方式。
- 故障恢复：主节点出现问题，可以由从节点提供服务，服务冗余
- 负载均衡：配合上读写分离，主机提供写服务，从机提供读服务，可以提高并发量
- 高可用(集群)基石：主从复制 是哨兵和集群能够实施的基础。

> 实现原理

- 连接建立阶段：在主从节点之间建立连接，为数据同步做好准备。

  - **从节点执行slaveof**，这个命令是异步的，从节点立即向客户端返回ok，然后在内部维护两个字段，masterhost和masterport字段，用于存储主节点的ip和port信息

  - **建立socket连接**：从节点每秒调用函数，如果发现有主节点可以连接，就根据主节点的ip和port建立socket连接，从节点为该socket建立一个专门处理复制工作的文件事件处理器 。 主节点接收到从节点的socket连接后（即accept之后），为该socket创建相应的客户端状态，并将从节点看做是连接到主节点的一个客户端

  - **发送ping命令**：从节点发送ping进行首次请求，检查socket连接是否可用。可能会有下面三种情况

    - （1）返回pong：说明socket连接正常，且主节点当前可以处理请求，复制过程继续。

      （2）超时：一定时间后从节点仍未收到主节点的回复，说明socket连接不可用，则从节点断开socket连接，并重连。

      （3）返回pong以外的结果：如果主节点返回其他结果，如正在处理超时运行的脚本，说明主节点当前无法处理命令，则从节点断开socket连接，并重连

  - **身份验证**：如果从节点中设置了masterauth选项，则从节点需要向主节点进行身份验证；从节点进行身份验证是通过向主节点发送auth命令进行的，auth命令的参数即为配置文件中的masterauth的值。如果主节点设置密码的状态，与从节点masterauth的状态一致(密码相同)，则身份验证通过，复制过程继续；如果不一致，则从节点断开socket连接，并重连。

  - **发送从节点端口信息**：从节点发送自己的端口号，主节点保存到该从节点对应的客户端的slave_listening_port字段。

- 数据同步阶段：从节点向主节点发送psync命令（Redis2.8以前是sync命令），开始同步。数据同步阶段是主从复制最核心的阶段，根据主从节点当前状态的不同，可以分为全量复制和增量复制。

- 命令传播阶段：数据同步阶段完成后，主从节点进入命令传播阶段；在这个阶段主节点将自己执行的写命令发送给从节点，从节点接收命令并执行，从而保证主从节点数据的一致性。**命令传播是异步的过程，即主节点发送写命令后并不会等待从节点的回复**；因此实际上主从节点之间很难保持实时的一致性，延迟在所难免。





一主二从，多个从机，一个主机。

如果主机挂掉了，怎么办？  可以其他的从机自己升级`SLAVEOF no one`



优点：

- 读写分离，减少了主节点压力

缺点：

- Redis不具备自动容错和恢复功能，主机从机的宕机都会导致前端部分读写请求失败，需要人工恢复
- 主机宕机，宕机前有部分数据未能及时同步到从机，切换后还会引入数据不一致的问题
- 如果多个从节点宕机了，不要在同一时间段重启，因为重启要发送sync请求和主机全量同步，会导致主节点IO增加，引起宕机
- Redis 较难支持在线扩容，在集群容量达到上限时在线扩容会变得很复杂；

#### 哨兵模式

主从切换技术的方法是：当主服务器宕机后，需要手动把一台从服务器切换为主服务器，这就需要人工 干预，费事费力，还会造成一段时间内服务不可用。

哨兵模式是一种特殊的模式，首先Redis提供了哨兵的命令，哨兵是一个独立的进程，作为进程，它会独
立运行。其原理是哨兵通过发送命令，等待Redis服务器响应，从而监控运行的多个Redis实例。

一个哨兵可能会出问题，加上多个哨兵，每个哨兵之间也互相监督

![image-20210722171518274](https://xy-picgo.oss-cn-shenzhen.aliyuncs.com/20210722171518.png)

> 心跳机制



- sentinel是特殊的Redis节点，哨兵模式创建时，需要通过配置指定 Sentinel 与 Redis Master Node 之间的关系**， Sentinel 会从主节点上获取所有从节点的信息**，然后定时向主节点和从节点发送 info 命令获取其拓扑结构和状态信息。

- 基于 Redis 的订阅发布功能， 每个 Sentinel 节点会向主节点的 `sentinel：hello `频道上发送该 Sentinel 节点对于主节点的判断以及当前 Sentinel 节点的信息 ，同时每个 Sentinel 节点也会订阅该频道， 来获取其他 Sentinel 节点的信息以及它们对主节点的判断。



通过以上两步所有的 Sentinel 节点以及它们与所有的 Redis 节点之间都已经彼此感知到，之后每个 Sentinel 节点会向主节点、从节点、**以及其余 Sentinel 节点**定时发送 **ping 命令作为心跳检测， 来确认这些节点是否可达**。



> 下线

每个 Sentinel 都会定时进行心跳检查，当发现主节点出现心跳检测超时的情况时，此时认为该主节点已经不可用，这种判定称为**主观下线**。之后这个Sentinel 会发送命令给其他Sentinel 节点询问对这个主节点的判断，当quorum(一般是Sentinel的1/2 +1，半数以上)个Sentinel 认为这个节点故障，就执行**客观下线**。



之后： Sentinel 节点之间会再做一次选举工作， 基于 **Raft 算法**选出一个` Sentinel 领导者`来进行故障转移的工作。

- 选一个节点作为新节点
- Sentinel 领导者节点会对选出来的从节点执行 slaveof no one 命令让其成为主节点。
- Sentinel 领导者节点会向剩余的从节点发送命令，让他们从新的主节点上复制数据。
- Sentinel 领导者会将原来的主节点更新为从节点， 并对其进行监控， 当其恢复后命令它去复制新的主节点。

> Sentinel怎么选出master

筛选出所有在线的slave，然后按照下面的标准进行选取

- slave 优先级 ：设置节点的优先级，优先级最高的直接变成master。如果没有优先级最高的，再判断复制进度
  - 可以通过 slave-priority 手动设置 slave 的优先级。
- 复制进度 ：Sentinel 总是希望选择出数据最完整（与旧 master 数据最接近）也就是复制进度最快的 slave 被提升为新的 master。
- runid(运行 id) ：如果有多个 slave 的优先级和复制进度一样的话，那就 **runid 小的成为新的 master**，每个 redis 节点启动时都有一个 40 字节随机字符串作为运行 id。（通常前两种就已经能够选出来了）

> 优缺点

优点：

- 系统可用性更好
- 这是主从模式的升级，更加健壮

缺点：

- 配置比较复杂
- edis较难支持在线扩容，在集群容量达到上限时在线扩容会变得很复杂。

#### Cluster集群

不管是主从模式还是哨兵模式都只能由一个master在写数据，在海量数据高并发场景，一个节点写数据容易出现瓶颈，引入Cluster模式可以实现多个节点同时写数据。

Redis 的哨兵模式基本已经可以实现高可用，读写分离 ，但是在这种模式下每台 Redis 服务器都存储相同的数据，很浪费内存，所以在 redis3.0上加入了 Cluster 集群模式，实现了 Redis 的分布式存储，**也就是说每台 Redis 节点上存储不同的内容**。

Redis-Cluster采用无中心结构，每个节点都保存数据，节点之间互相连接从而知道整个集群状态。



redis cluster ： 多个master组成集群，然后每个master又基于主从复制，会带着slave节

功能： **负载均衡，故障切换，主从复制**



Redis 集群没有使用一致性 hash，而是引入了哈希槽【hash slot】的概念。

##### Redis哈希槽

Redis 集群有16384 个哈希槽，每个 key 通过 CRC16 校验后对 16384 取模来决定放置哪个槽。集群的每个节点负责一部分hash槽，举个例子，比如当前集群有3个节点，那么：

- 节点 A 包含 0 到 5460 号哈希槽
- 节点 B 包含 5461 到 10922 号哈希槽
- 节点 C 包含 10923 到 16383 号哈希槽

当redis客户端设置值时，会拿key进行CRC16算法，然后 跟16384取模。`slot = CRC16(key) & 16383`  根据记录就能找出是哪个节点管理这个槽。

```
这样使用，我们为每个节点创建一个jedis对象实例，然后通过slots.get（ slot）就能获取到对应槽的节点的连接jedis，然后进行操作
```



这种结构很容易添加或者删除节点。比如如果我想新添加个节点 D ， 我需要从节点 A， B， C 中得部分槽到 D 上。如果我想移除节点 A ，需要将 A 中的槽移到 B 和 C 节点上，然后将没有任何槽的 A 节点从集群中移除即可。





#### redis集群最大个数

16384



- 

#### redis集群数量常用配置

> 主从复制

1主2从

> 哨兵

1主2从3哨兵

> 集群模式

3主3从



### redis分布式锁

参考文章：http://kaito-kidd.com/2021/06/08/is-redis-distributed-lock-really-safe/ 后面还有些深入的暂时没看

- Setnx+过期时间（以前还需要考虑原子性，现在redis自己放进一个命令去了），问题：**客户1加锁成功，锁住了，执行时间超时，此时客户2进来加锁成功，客户1执行完毕，会删除客户2的锁**
- 为了解决上面的问题，控制过期时间（网络复杂，这块并不能完成解决）。设置value唯一标识，比如uuid，在解锁的时候比较一下，看看是不是自己的锁。（get(key)==value ,del key）。设计到原子性的问题，可以把命令封装到lua脚本中执行
- 控制过期时间，冗余过期时间--**加锁时，先设置一个过期时间，然后我们开启一个「守护线程」，定时去检测这个锁的失效时间，如果锁快要过期了，操作共享资源还未完成，那么就自动对锁进行「续期」，重新设置过期时间。** -- **Redisson**的做法
- 通常使用Redis会做集群（主从切换的话，分布式锁就有问题）。Redlock提出来解决-- 



#### Redlock 真的安全？

Redlock 的方案基于 2 个前提：

- 不需要部署从库和哨兵，只部署主库
- 主库部署多个，官方推荐至5个

> **注意：不是部署 Redis Cluster，就是部署 5 个简单的 Redis 实例。**

流程：

- 客户端获取当前时间戳T1
- 客户端依次向5个redis实例发起加锁请求，请求设置超时时间（请求的超时ms，小于锁的有效时间），如果一个实例加锁失败（网络超时，锁被其他人持有），立即向下一个redis实例申请加锁
- 如果客户端>=3 的redis加锁成功（大多数），则获取当前时间戳T2，，如果T2-T1 < 锁的过期时间，客户端认为加锁成功，否则失败
- 加锁成功，操作共享资源
- 加锁失败，向全部节点发起释放锁的请求（lua脚本）

 

### 缓存读写策略

#### 3种常用的缓存读写策略

##### 1.Cache Aside Pattern 旁路缓存

Cache Aside Pattern 是我们平时使用比较多的一个缓存读写模式，**比较适合读请求比较多的场景。**

Cache Aside Pattern 中服务端需要同时维系 DB 和 cache，并且是以 DB 的结果为准。

读写步骤：

- 写
  - 先更新DB
  - 直接删除cache
- 读
  - 从cache中读取数据，读取到就直接返回
  - 没有，就去DB中找
  - 把数据放入cache

> 为什么先删除cache而不是更新cache

- **对服务端资源造成浪费**：
- 产生数据不一致问题 

> 提问： 写数据可以先删缓存再更新DB吗

不行，会造成数据不一致的问题。

- 请求1删除缓存
- 请求2读数据A，没有缓存，更新到cache里
- 请求1更新DB

这时候，缓存里的A就是原来的旧值，可能会有问题



=》 那么先更新DB再删缓存就一定没问题？

**answer**：理论上来说还是可能会出现数据不一致性的问题，不过概率非常小，因为缓存的写入速度是比数据库的写入速度快很多！

> 模式的缺点

- 首次请求数据一定不在cache中
  - 解决办法：热点数据提前放入cache中
- 写操作比较频繁，会cache中的数据会被频繁删除，就会影响缓存命中率
  - 两种场景下的解决办法如下
  - **数据库和缓存数据强一致场景** ：更新DB的时候同样更新cache，不过我们需要加一个**锁/分布式锁**来保证更新cache的时候不存在线程安全问题。
  - 可以**短暂地允许数据库和缓存数据不一致**的场景 ：更新DB的时候同样更新cache，但是给缓存**加一个比较短的过期时间**，这样的话就可以保证即使数据不一致的话影响也比较小。



##### 2.Read/write through pattern 读写穿透

Read/Write Through Pattern 中服务端把 cache 视为主要数据存储，从中读取数据并将数据写入其中。cache 服务负责将此数据读取和写入 DB

- 写：
  - 先查cache，cache不存在，直接更新DB(在DB里面修改，不更新cache)
  - cache存在，先更新cache，然后cache服务自己更新DB和cache
- 读
  - 从cache中读，读到就返回
  - 读不到，就去DB加载，写入到cache然后返回响应

和 Cache Aside Pattern 一样， Read-Through Pattern 也有首次请求数据一定不再 cache 的问题，对于热点数据可以提前放入缓存中。

##### 3.Write Behind Pattern（异步缓存写入）

和Read/write through pattern很像，都是用cache来负责cache和DB的读写

也有很大的区别：Read/write through pattern是同步更新cache和DB的。而write behind pattern则是异步更新，先更新完cache，**再用异步批量的方式来更新 DB**。

会存在还没更新完DB，cache挂掉的风险。

**优点**： 写性能非常高，适合用于数据一致性要求不高的地方。比如浏览量、点赞量等



### 性能

#### redis常见性能问题

- Master最好不要写内存快照，save调度rdbSave函数，会阻塞主线程工作
- 数据比较重要的话，Slave开启AOF备份，设置为每秒同步
- 避免在压力很大的主库上增加从库

#### 加入Redis里面有1亿个key，其中有10w个key是以固定的前缀开头，如何找出来

使用keys指令 。

> 如果这个redis正在提供服务，使用keys会有什么问题

redis是单线程的，keys指令会导致线程阻塞一段时间，线上服务会停顿，一直到指令执行完毕，服务才能恢复。那么我们可以scan指令，scan可以无阻塞的提取出指定模式的key列表，会有一定的重复，做一次去重就可以了。时间花费会比keys长

