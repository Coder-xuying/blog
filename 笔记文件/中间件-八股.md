# Kafka

#### 1.发布订阅模型



#### 2.kafka重复消费

> why does it repeat?

the data that  already consumed on the server-side was not successfully submitted in offset(consumer downtime)

> how to solve the problem of repeated consumption ?

- Idempotent checks(幂等校验),such as redis's set , mysql's primary key

- 关闭自动提交，改为手动提交，怎么



# Spring

#### 1.springboot的自动配置原理

自动装配可以简单理解为：**通过注解或者一些简单的配置就能在 Spring Boot 的帮助下实现某块功能。**

先看一下 SpringBoot 的核心注解 `SpringBootApplication`  

上面那个注解里面有 `@Configuration`、`@EnableAutoConfiguration`、`@ComponentScan` 注解的集合



- `@EnableAutoConfiguration`：启用 SpringBoot 的自动配置机制   **是实现自动装配的重要注解，我们以这个注解入手**
- `@Configuration`：允许在上下文中注册额外的 bean 或导入其他配置类
- `@ComponentScan`： 扫描被`@Component` (`@Service`,`@Controller`)注解的 bean，注解默认会扫描启动类所在的包下所有的类 ，可以自定义不扫描某些 bean。



@EnableAutoConfiguration 有AutoConfigurationImportSelector，

自动装配核心功能的实现实际是通过 `AutoConfigurationImportSelector`类。 加载自动装配类

`AutoConfigurationImportSelector` 类里面有个方法 (`selectImports`方法)，该方法主要用于**获取所有符合条件的类的全限定类名，这些类需要被加载到 IoC 容器中**。



#### [1.Spring AOP 和 AspectJ AOP 有什么区别？](https://snailclimb.gitee.io/javaguide/#/docs/system-design/framework/spring/Spring常见问题总结?id=spring-aop-和-aspectj-aop-有什么区别？)

**Spring AOP 属于运行时增强，而 AspectJ 是编译时增强。** Spring AOP 基于代理(Proxying)，而 AspectJ 基于字节码操作(Bytecode Manipulation)。

Spring AOP 已经集成了 AspectJ ，AspectJ 应该算的上是 Java 生态系统中最完整的 AOP 框架了。AspectJ 相比于 Spring AOP 功能更加强大，但是 Spring AOP 相对来说更简单，

如果我们的切面比较少，那么两者性能差异不大。但是，当切面太多的话，最好选择 AspectJ ，它比 Spring AOP 快很多





### SpringBean

#### springBean的作用域

- **singleton** : 唯一 bean 实例，Spring 中的 bean 默认都是单例的，对单例设计模式的应用。
- **prototype** : 每次请求都会创建一个新的 bean 实例。
- **request** : 每一次 HTTP 请求都会产生一个新的 bean，该 bean 仅在当前 HTTP request 内有效。
- **session** : 每一次 HTTP 请求都会产生一个新的 bean，该 bean 仅在当前 HTTP session 内有效。
- **global-session** ： 全局 session 作用域，仅仅在基于 portlet 的 web 应用中才有意义，Spring5 已经没有了。Portlet 是能够生成语义代码(例如：HTML)片段的小型 Java Web 插件。它们基于 portlet 容器，可以像 servlet 一样处理 HTTP 请求。但是，与 servlet 不同，每个 portlet 都有不同的会话。



#### [@Component 和 @Bean 的区别是什么？](https://snailclimb.gitee.io/javaguide/#/docs/system-design/framework/spring/Spring常见问题总结?id=component-和-bean-的区别是什么？)

1. `@Component` 注解作用于类，而`@Bean`注解作用于方法。
2. `@Component`通常是通过类路径扫描来自动侦测以及自动装配到 Spring 容器中（我们可以使用 `@ComponentScan` 注解定义要扫描的路径从中找出标识了需要装配的类自动装配到 Spring 的 bean 容器中）。`@Bean` 注解通常是我们在标有该注解的方法中定义产生这个 bean,`@Bean`告诉了 Spring 这是某个类的实例，当我需要用它的时候还给我。
3. `@Bean` 注解比 `@Component` 注解的自定义性更强，而且很多地方我们只能通过 `@Bean` 注解来注册 bean。比如当我们引用第三方库中的类需要装配到 `Spring`容器时，则只能通过 `@Bean`来实现。

#### Bean的生命周期

![image-20210908161818758](https://xy-picgo.oss-cn-shenzhen.aliyuncs.com/20210908161818.png)



#### Spring框架中有哪些设计模式

- **工厂设计模式** : Spring 使用工厂模式通过 `BeanFactory`、`ApplicationContext` 创建 bean 对象。
- **代理设计模式** : Spring AOP 功能的实现。

- **单例设计模式** : Spring 中的 Bean 默认都是单例的。

### [Spring 事务](https://snailclimb.gitee.io/javaguide/#/docs/system-design/framework/spring/Spring常见问题总结?id=spring-事务)

#### Spring 管理事务的方式有几种？

- **编程式事务** ： 在代码中硬编码(不推荐使用) : 通过 `TransactionTemplate`或者 `TransactionManager` 手动管理事务，实际应用中很少使用，但是对于你理解 Spring 事务管理原理有帮助。
- **声明式事务** ： 在 XML 配置文件中配置或者直接基于注解（推荐使用） : 实际是通过 AOP 实现（基于`@Transactional` 的全注解方式使用最多）



#### Spring事务的传播级别

***\*PROPAGATION_REQUIRED\**** ，默认的spring事务传播级别，如果上下文中已经存在事务，那么就加入到事务中执行，如果当前上下文中不存在事务，则新建事务执行。

***\*PROPAGATION_REQUIRES_NEW\**** ，每次都要一个新事务，该传播级别的特点是，每次都会新建一个事务，并且同时将上下文中的事务挂起，执行当前新建事务完成以后，上下文事务恢复再执行。

***\*PROPAGATION_SUPPORTS\**** ，如果上下文存在事务，则支持事务加入事务，如果没有事务，则使用非事务的方式执行。

***\*PROPAGATION_NOT_SUPPORTED\**** ，上下文中存在事务，则挂起事务，执行当前逻辑，结束后恢复上下文的事务。

***\*PROPAGATION_MANDATORY\**** ， 该级别的事务要求上下文中必须要存在事务，否则就会抛出异常！

***\*PROPAGATION_NEVER\****，上下文中不能存在事务，一旦有事务，就抛出runtime异常，强制停止执行！

***\*PROPAGATION_NESTED\**** ，如果上下文中存在事务，则嵌套事务执行，如果不存在事务，则新建事务。



> 什么是嵌套事务

子事务套在父事务中执行，子事务是父事务的一部分，在进入子事务之前，父事务建立一个回滚点，叫save point，然后执行子事务，这个子事务的执行也算是父事务的一部分，然后子事务执行结束，父事务继续执行。

- ***如果子事务回滚，会发生什么？\**** 
  - 父事务会回滚到进入子事务前建立的save point，然后尝试其他的事务或者其他的业务逻辑，父事务之前的操作不会受到影响，更不会自动回滚

- ***\*如果父事务回滚，会发生什么？\**** 
  - 父事务回滚，子事务也会跟着回滚！为什么呢，因为父事务结束之前，子事务是不会提交的，我们说子事务是父事务的一部分，正是这个道理。
- ***\*事务的提交，是什么情况？\**** 
  - 子事务先提交，父事务再提交





# Netty

Netty的异步不是异步IO而是 调用异步，使用IO多路复用，然后

#### 1.Netty是什么？

- netty是一个基于NIO的C/S框架，用它可以快速简单的开发网络应用程序
- 简化了TCP和UDP套接字服务器等网络编程，性能和安全性也更好
- 支持多种协议  - FTP、SMTP、HTTp等

#### 2.为什么用Netty

 Netty 具有下面这些优点

- 简单性能高
- 自带编码器解决TCP 沾包/拆包问题
- 安全性高
- 社区活跃，比较稳定
- 很多开源项目都用了，比如Dubbo、RocketMQ

#### 3.Netty 应用场景了解么？

- RPC框架的网络通信工具
- HTTp服务器
- 即使通讯系统
- 消息推送系统



#### 4、Netty的核心组件

- Channel：包含基本的IO操作，bind、connect、read、write。常用的实现类是NioServerSocketChannel （服务端）和 NioSocketChannel。分别对应 ServerSocket 以及 Socket
- EventLoop： 负责监听⽹络事件并调⽤**事件处理器(handler)**进⾏相关 I/O 操 作的处理,相当于反应器模式里面的reactor，EventLoop 负责处理注册到其上的 Channel
- ChannelFuture：Netty 是异步⾮阻塞的，所有的 I/O 操作都为异步的。你可以通过 ChannelFuture 接⼝的 addListener() ⽅法注册⼀个 ChannelFutureListener ，当操作执⾏成功或者失败时，监听就会⾃动触发返回结果。我们还可以通过 ChannelFuture 接⼝的 sync() ⽅法让异步的操作变成同步的。
- ChannelHandler 和 ChannelPipeline
  - ChannelHandler 是消息的具体处理器，负责处理读写操作、客户端连接等事情。
  - ChannelPipeline 为 ChannelHandler 的链，提供了⼀个容器并定义了⽤于沿着链传播⼊站和出站 事件流的 API 。通过 addLast() ⽅法添加⼀个或者多个 ChannelHandler ，因为⼀ 个数据或者事件可能会被多个 Handler 处理

#### 5、EventLoop中设置的线程数

```java
// 方法最后是运行的这个方法，可以看到当设置为0 的时候去找默认的 DEFAULT_EVENT_LOOP_THREADS 数量
protected MultithreadEventLoopGroup(int nThreads, Executor executor, Object... args) {
    super(nThreads == 0 ? DEFAULT_EVENT_LOOP_THREADS : nThreads, executor, args);
}  


private static final int DEFAULT_EVENT_LOOP_THREADS;
// 这个默认的数量在静态方法中设置为cpu核数的两倍，netty运行时获得
DEFAULT_EVENT_LOOP_THREADS = Math.max(1, SystemPropertyUtil.getInt(
                "io.netty.eventLoopThreads", NettyRuntime.availableProcessors() * 2));

```



# Zookeeper



### 1.基础

#### 1.Zookeeper的特点

![image-20210811154037264](https://xy-picgo.oss-cn-shenzhen.aliyuncs.com/20210811154037.png)



leader进行写，follower读。

为什么适合奇数，因为5台挂了三台就不能用，6台集群也是挂三台就不能用，浪费了一台。所以更适合奇数台



#### 2.数据结构

![image-20210811154935005](https://xy-picgo.oss-cn-shenzhen.aliyuncs.com/20210811154935.png)

#### 3.应用场景

![image-20210811155015293](https://xy-picgo.oss-cn-shenzhen.aliyuncs.com/20210811155015.png)



> 统一命名服务

![image-20210811155152942](https://xy-picgo.oss-cn-shenzhen.aliyuncs.com/20210811155153.png)

> 统一配置管理

![image-20210811155301909](https://xy-picgo.oss-cn-shenzhen.aliyuncs.com/20210811155302.png)



> 统一集群管理

![image-20210811155413689](https://xy-picgo.oss-cn-shenzhen.aliyuncs.com/20210811155413.png)

管理集群的状态。

> 软负载均衡

![image-20210811185348597](https://xy-picgo.oss-cn-shenzhen.aliyuncs.com/20210811185348.png)







### 4、源码分析

#### 1.算法基础

##### 1.1 拜占庭将军问题

将军们必须全体一致是否攻击某一支敌军，然后各个将军的部队都是分离的，里面有叛徒。必须所有的将军都同意，才能做出决定。

##### 1.2 Paxos算法

![image-20210813205226484](https://xy-picgo.oss-cn-shenzhen.aliyuncs.com/20210813205226.png)

##### ZAB协议

在Paxos算法上改进的协议，Zookeeper用的是这个  ==两阶段提交==



![image-20210813210403079](https://xy-picgo.oss-cn-shenzhen.aliyuncs.com/20210813210403.png)

![image-20210813210438539](https://xy-picgo.oss-cn-shenzhen.aliyuncs.com/20210813210438.png)



> 崩溃恢复-异常假设

两种情况：

- leader在commit发出去之后，挂了，所有的follower必须提交
- leader在commit还没有发就挂了，那么提案就丢掉

> 崩溃恢复 - leader选举

![image-20210813210828824](https://xy-picgo.oss-cn-shenzhen.aliyuncs.com/20210813210828.png)



> 数据恢复

![image-20210813210952128](https://xy-picgo.oss-cn-shenzhen.aliyuncs.com/20210813210952.png)

### CAP理论

#### 1.ZooKeeper 是什么？

ZooKeeper 是一个分布式协调服务，它是集群的管理者，监视着集群中各个节点的状态根据节点提交的反馈进行下一步合理操作。最终，将简单易用的接口和性能高效、功能稳定的系统提供给用户。
ZooKeeper 为我们提供了高可用、高性能、稳定的分布式数据一致性解决方案，通常被用于实现诸如数据发布/订阅、负载均衡、命名服务、分布式协调/通知、集群管理、Master 选举、分布式锁和分布式队列等功能。**ZooKeeper 将数据保存在内存中，性能是非常棒的。**

客户端的读请求可以被集群中的任意一台机器处理，对于写请求，这些请求会同时发给其他 zookeeper 机器并且达成一致后，请求才会返回成功。因此，随着 zookeeper 的集群机器增多，读请求的吞吐会提高但是写请求的吞吐会下降。



有序性是 zookeeper 中非常重要的一个特性，所有的更新都是全局有序的，每个更新都有一个唯一的时间戳，这个时间戳称为 zxid（Zookeeper Transaction Id）

#### Zookeeper特点

- **顺序一致性：** 从同一客户端发起的事务请求，最终将会严格地按照顺序被应用到 ZooKeeper 中去。
- **原子性：** 所有事务请求的处理结果在整个集群中所有机器上的应用情况是一致的，也就是说，要么整个集群中所有的机器都成功应用了某一个事务，要么都没有应用。
- **单一系统映像 ：** 无论客户端连到哪一个 ZooKeeper 服务器上，其看到的服务端数据模型都是一致的。
- **可靠性：** 一旦一次更改请求被应用，更改的结果就会被持久化，直到被下一次更改覆盖。

#### 2.zookeeper的文件系统

Zookeeper 提供一个多层级的节点命名空间（节点称为 znode）。与文件系统不同的是，**这些节点都可以设置关联的数据**，而文件系统中只有文件节点可以存放数据而目录节点不行。Zookeeper 为了保证高吞吐和低延迟，在内存中维护了这个树状的目录结构，所以Zookeeper 不能用于存放大量的数据，每个节点的存放数据上限为1M。

#### zookeeper应用场景

- 分布式锁：创建唯一节点获得分布式锁，当获得锁的一方执行完相关代码或者是挂掉之后就释放锁。
- **命名服务** ：可以通过 ZooKeeper 的顺序节点生成全局唯一 ID
- **数据发布/订阅** ：通过 **Watcher 机制** 可以很方便地实现数据发布/订阅。当你将数据发布到 ZooKeeper 被监听的节点上，其他机器可通过监听 ZooKeeper 上节点的变化来实现配置的动态更新。

### 基本概念



#### 数据模型

ZooKeeper 数据模型采用层次化的多叉树形结构，每个节点上都可以存储数据，这些数据可以是数字、字符串或者是二级制序列。每个node可以存1M

![image-20210822130851841](https://xy-picgo.oss-cn-shenzhen.aliyuncs.com/20210822130858.png)

#### 数据节点

> Znode四种类型

- **持久（PERSISTENT）节点** ：一旦创建就一直存在即使 ZooKeeper 集群宕机，直到将其删除。
- **临时（EPHEMERAL）节点** ：临时节点的生命周期是与 **客户端会话（session）** 绑定的，**会话消失则节点消失** 。并且，**临时节点只能做叶子节点** ，不能创建子节点。
- **持久顺序（PERSISTENT_SEQUENTIAL）节点** ：除了具有持久（PERSISTENT）节点的特性之外， 子节点的名称还具有顺序性。比如 `/node1/app0000000001` 、`/node1/app0000000002` 。
- **临时顺序（EPHEMERAL_SEQUENTIAL）节点** ：除了具备临时（EPHEMERAL）节点的特性之外，子节点的名称还具有顺序性。

> znode数据结构

每个 znode 由 2 部分组成:

- **stat** ：状态信息
  - cZxid	create ZXID，即该数据节点被创建时的事务 id
  - mZxid	modified ZXID，即该节点最终一次更新时的事务 id
  - aclVersion	节点的 ACL 版本号，表示该节点 ACL 信息变更次数
- **data** ： 节点存放的数据的具体内容

> ACL (权限控制)

对于 znode 操作的权限，ZooKeeper 提供了以下 5 种：

- **CREATE** : 能创建子节点
- **READ** ：能获取节点数据和列出其子节点
- **WRITE** : 能设置/更新节点数据
- **DELETE** : 能删除子节点
- **ADMIN** : 能设置节点 ACL 的权限



### 1.Zookeeper的选举制度

> 第一次初始化的时候

假设有五台机器，需要上线三台才能选举成功

- 首先，第一台服务器上线，投票给自己，未到半数以上
- 然后第二台上线，都投给自己，并交换选票的信息，此时第一台服务器发现另外一台的myid大于自己的，就把选票给了第二台服务器
- 第三台服务器上线，投给了自己，交换选票信息，第二台发现第三台的myid大于自己的，就把选票给第三台了，此时选票数大于半数，leader选举成功。
- 此时如果有第四台上线，投给自己，因为第三台的票数》第四台的，直接成为follower，并把选票给leader

> 非第一次启动的情况

无服务运行期间无法和leader保持连接： 两种情况

- 集群中有leader但是连接不上
  - 想去选举的话，其他机器会告诉他leader还在，你要去继续尝试连接
- 集群中的leader挂掉了



![image-20210811192916829](https://xy-picgo.oss-cn-shenzhen.aliyuncs.com/20210811192916.png)

字段的意思：

- SID，服务器的ID，用来标识集群中的机器
- ZXID，事务ID，就是标识这个服务器状态变更的次数，比如做了一次操作就加1
- Epoch，投票的次数，比如初始化之后，他们就是1，第二次投票就变成2了

leader挂掉按照下面的步骤选取：

假设有五台机器，SID分别是1,2,3,4,5 ，ZXID分别是8,8,8,7,7. 然后SID为3的机器是Leader，此时，3和5号机器挂掉了，开始进行Leader选举

![image-20210811193130016](https://xy-picgo.oss-cn-shenzhen.aliyuncs.com/20210811193130.png)

EPOCH越大代表他存在的时间越长，
