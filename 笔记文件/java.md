## 泛型

##### 泛型接口

```java
interface Info<T>{        // 在接口上定义泛型  
    public T getVar() ; // 定义抽象方法，抽象方法的返回值就是泛型类型  
} 
class InfoImpl<T> implements Info<T>{   // 定义泛型接口的子类  
    private T var ;             // 定义属性  
    public InfoImpl(T var){     // 通过构造方法设置属性内容  
        this.setVar(var) ;    
    }  
    public void setVar(T var){  
        this.var = var ;  
    }  
    public T getVar(){  
        return this.var ;  
    }  
} 

```

##### 泛型方法

```java
// 必须指定<T>，声明这是一个泛型方法，持有一个泛型T
// Class<T>的作用就是指明泛型的具体类型,变量c，可以用来创建泛型类的对象。（利用反射，因为我们不知道传入的泛型类型）
public <T> T getObject(Class<T> c){
  
}
```

##### 泛型的上下限

> 上限

`<? extends A>`表示该类型参数可以是A(上边界)或者A的子类类型。编译时擦除到类型A，即用A类型代替类型参数。

```java
public static void funC(List<? extends A> listA) {  // 如果不用extends ，下面方法执行会报错
    // ...          
}
public static void funD(List<B> listB) {
    funC(listB); // OK
    // ...             
}
```

> 下限

```java
public static void fun(Info<? super String> temp){    // 只能接收String或Object类型的泛型，String类的父类只有Object类
  System.out.print(temp + ", ") ;
}
```

> 总结

```java
<?> 无限制通配符
<? extends E> extends 关键字声明了类型的上界，表示参数化的类型可能是所指定的类型，或者是此类型的子类
<? super E> super 关键字声明了类型的下界，表示参数化的类型可能是指定的类型，或者是此类型的父类

// 为了获得最大限度的灵活性，要在表示 生产者或者消费者 的输入参数上使用通配符，使用的规则就是：生产者有上限、消费者有下限
1. 如果参数化类型表示一个 T 的生产者，使用 < ? extends T>;
2. 如果它表示一个 T 的消费者，就使用 < ? super T>；
3. 如果既是生产又是消费，那使用通配符就没什么意义了，因为你需要的是精确的参数类型。

```





## 1、锁

#### 1、乐观锁和悲观锁

- 悲观锁
  - 对于同一个数据的并发操作，悲观锁自己使用数据的时候一定会有别的线程来修改数据，在获取的时候先加锁。synchronized关键字和Lock的实现类都是悲观锁。
  - 适合写操作多的场景
- 乐观锁
  - 乐观锁认为不会有其他线程来修改数据，所以不会添加锁，在更新数据的时候去判断有没有别的线程更新了这个数据。如果数据没有更新，则将自己的修改写入，否则会根据不同的实现出不同的操作（比如报错或者重试）。
  - 乐观锁在Java中是通过使用无锁编程来实现，最常采用的是CAS算法，Java原子类中的递增操作就通过CAS自旋实现的。
  - 适合读操作多的场景，不加锁性能高

> CAS

Compare And Swap ：

CAS算法设计三个操作数：

- 读写内存值V
- 比较V和值A是否相等
- 用新值B更新值V 
- **注意事项**
  - 更新会不断地重试
  - 比较+更新整体是一个原子操作 == 。整个“比较+更新”操作封装在compareAndSwapInt()中，在JNI里是借助于一个CPU指令完成的，属于原子操作，可以保证多个线程都能够看到同一个变量的修改值。
- **问题**
  - ABA问题：比如内存值原来是A，后来变成B，然后又变成了A，CAS检查的时候以为值没有变化
    - 解决思路：版本号，更新就+1；
    - JDK从1.5开始提供了AtomicStampedReference类来解决ABA问题，具体操作封装在compareAndSet()中。compareAndSet()首先检查**当前引用和当前标志与预期引用和预期标志**是否相等，如果都相等，则以原子方式将引用值和标志的值设置为给定的更新值。-- 其实就是一个引用值和标记值
  - 循环时间长开销大，CAS长时间不成功，会一直自旋，对CPU的开销大
  - 只能保证一个共享变量的原子操作
    - 对一个共享变量执行操作时，CAS能够保证原子操作，但是对多个共享变量操作时，CAS是无法保证操作的原子性的。
    - Java从1.5开始JDK提供了AtomicReference类来保证引用对象之间的原子性，可以把多个变量放在一个对象里来进行CAS操作。

#### 2、自旋锁和适应性自旋锁

阻塞或唤醒一个Java线程需要操作系统切换CPU状态来完成，这种状态转换需要耗费处理器时间。切换线程保留上下文等执行耗时比较大，切换线程执行就得不偿失。如果有多个处理器，并多个线程并行执行，让请求锁的线程不放弃CPU的执行，自旋等待锁释放。

![img](https://awps-assets.meituan.net/mit-x/blog-images-bundle-2018b/452a3363.png)

自旋锁问题：虽然避免线程切换的开销，但是会占用处理器的时间，长时间等待浪费资源

- 自旋锁等待时间有限制的，比如自旋超过限定次数，就应该挂起线程
  - 默认是10次，可以使用-XX:PreBlockSpin来更改



适应性自旋锁：

- 就是自旋的（时间）次数不是固定的，前一次在同一个锁上的自旋时间及锁的拥有者的状态来决定。
- 什么意思了：看下面的例子
  - 如果前一次自旋等待获得锁成功，jvm就认为这次自旋也可能成功，就让自旋时间加长
  - 如果对于某个锁，自旋很少成功获得过，那在以后尝试获取这个锁时将可能省略掉自旋过程，直接阻塞线程，避免浪费处理器资源。

