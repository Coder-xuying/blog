## 1、锁

#### 1、乐观锁和悲观锁

- 悲观锁
  - 对于同一个数据的并发操作，悲观锁自己使用数据的时候一定会有别的线程来修改数据，在获取的时候先加锁。synchronized关键字和Lock的实现类都是悲观锁。
  - 适合写操作多的场景
- 乐观锁
  - 乐观锁认为不会有其他线程来修改数据，所以不会添加锁，在更新数据的时候去判断有没有别的线程更新了这个数据。如果数据没有更新，则将自己的修改写入，否则会根据不同的实现出不同的操作（比如报错或者重试）。
  - 乐观锁在Java中是通过使用无锁编程来实现，最常采用的是CAS算法，Java原子类中的递增操作就通过CAS自旋实现的。
  - 适合读操作多的场景，不加锁性能高

> CAS

Compare And Swap ：

CAS算法设计三个操作数：

- 读写内存值V
- 比较V和值A是否相等
- 用新值B更新值V 
- **注意事项**
  - 更新会不断地重试
  - 比较+更新整体是一个原子操作 == 。整个“比较+更新”操作封装在compareAndSwapInt()中，在JNI里是借助于一个CPU指令完成的，属于原子操作，可以保证多个线程都能够看到同一个变量的修改值。
- **问题**
  - ABA问题：比如内存值原来是A，后来变成B，然后又变成了A，CAS检查的时候以为值没有变化
    - 解决思路：版本号，更新就+1；
    - JDK从1.5开始提供了AtomicStampedReference类来解决ABA问题，具体操作封装在compareAndSet()中。compareAndSet()首先检查**当前引用和当前标志与预期引用和预期标志**是否相等，如果都相等，则以原子方式将引用值和标志的值设置为给定的更新值。-- 其实就是一个引用值和标记值
  - 循环时间长开销大，CAS长时间不成功，会一直自旋，对CPU的开销大
  - 只能保证一个共享变量的原子操作
    - 对一个共享变量执行操作时，CAS能够保证原子操作，但是对多个共享变量操作时，CAS是无法保证操作的原子性的。
    - Java从1.5开始JDK提供了AtomicReference类来保证引用对象之间的原子性，可以把多个变量放在一个对象里来进行CAS操作。

#### 2、自旋锁和适应性自旋锁

阻塞或唤醒一个Java线程需要操作系统切换CPU状态来完成，这种状态转换需要耗费处理器时间。切换线程保留上下文等执行耗时比较大，切换线程执行就得不偿失。如果有多个处理器，并多个线程并行执行，让请求锁的线程不放弃CPU的执行，自旋等待锁释放。

![img](https://awps-assets.meituan.net/mit-x/blog-images-bundle-2018b/452a3363.png)

自旋锁问题：虽然避免线程切换的开销，但是会占用处理器的时间，长时间等待浪费资源

- 自旋锁等待时间有限制的，比如自旋超过限定次数，就应该挂起线程
  - 默认是10次，可以使用-XX:PreBlockSpin来更改



适应性自旋锁：

- 就是自旋的（时间）次数不是固定的，前一次在同一个锁上的自旋时间及锁的拥有者的状态来决定。
- 什么意思了：看下面的例子
  - 如果前一次自旋等待获得锁成功，jvm就认为这次自旋也可能成功，就让自旋时间加长
  - 如果对于某个锁，自旋很少成功获得过，那在以后尝试获取这个锁时将可能省略掉自旋过程，直接阻塞线程，避免浪费处理器资源。

