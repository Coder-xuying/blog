### mysql

#### 1、存储引擎myISAM 和innoDb的区别

- myisam只支持表级锁，InnoDB 支持行锁和表级锁，innoDB性能更好
- myisam 不支持事务，innodb支持事务
- MyISAM 不支持外键，而 InnoDB 支持。
- MyISAM 不支持数据库崩溃后恢复，而 InnoDB 支持

#### 2、有哪些索引

主键索引：数据库的主键列，主键不能为null，也不能重复

二级索引：

- 普通索引：加快查询数据，允许数据重复和null
- 唯一索引：不能有重复数据，可以有null，主要作用是为了数据的唯一性而不是为了查询效率，这个会影响写入的效率
- 前缀索引：字符串类型的数据，对文本的前几个字符创建索引



> 聚簇索引和非聚簇索引

聚簇索引：

- 索引结构和数据一个文件存放的索引，比如innoDB的主键索引
- 优点：查询速度快，对排序查找和范围查找优化
- 缺点：更新代价大，依赖有序的数据

非聚簇索引：

- 索引结构和数据分开存放的索引，查询数据会回表，如果存在**覆盖索引**的情况，也就是二级索引中已经包含要查询的所有数据就不需要回表了
- 优点：更新的代价小
- 缺点：可能会二次查询

> 联合索引

用 表中的多个字段一起创建索引

最左前缀匹配原则指的是在一个复合索引中，查询条件必须要从索引的最左边列开始连续匹配，才能有效利用该索引进行查询。当遇到范围查询时（如 > 、< 、BETWEEN、LIKE 等），匹配将停止，但范围条件依旧有效。

示例

a、b、c三个符合索引

where a = xx and b =xx 就会用ab的索引

where a = "" and c = "" 只会用a的索引

where a = "" and b > "" and c = "" 这个则会用ab的索引不会用c



mysql数据是存在磁盘上的，一次磁盘访问的速度是ms级别远小于内存访问速度，另外mysql是支持范围查询的，所以mysql要设计索引应该要满足下面这些要求：

1、尽可能少的进行磁盘IO

2、能高效的查询某一条记录，也能高效的进行范围查询

首先想到的是二叉查找树O(logn)，但是如果插入是有序的，它会退化为链表，查询效率变成On了，此外树是存储在磁盘中的，访问一个节点就得进行一次磁盘IO，树越高就越影响查询性能

然后平衡二叉查找树，它和二叉查找树的区别是左右两个子树高度相差不能超过1，也就能维持查询效率，另外还有红黑树这种，但是二叉树他们每个节点只能保留2个子节点，数据比较多时，树的高度也会很高。如果我们每个节点允许M个子节点，这就是B树，也叫多叉树，B+树是B树的升级，它们的差异是

- B+的叶子节点存储数据，非叶子节点只存放索引
- 所有索引指向的数据都会在叶子节点出现，叶子节点之间构成一个有序链表
- 非叶子节点的索引

> 和B树比优点和缺点是什么

优点：

- B+树的非叶子节点只存储索引能够存储的记录更多，树的层级更少，查找平均效率会更高
- B+树支持范围查询，叶子节点是一个链表连接起来的 （innoDB的是双向链表）
- B+树遍历更快
- B+树查询速度稳定，都要去叶子节点查询数据
- 插入和删除的效率更高（？？）

缺点：

- B树中查找的数据离根节点近时，查询会更快

#### 2、什么是事务，数据库的事务隔离级别有哪些？各有哪些优缺点？

参考：https://blog.csdn.net/zycxnanwang/article/details/105742160

事务的四个特性

> 原子性

- 一个事务中的所有操作，要么都完成，要么都不完成，在执行过程中发生问题，会被回滚到事务开始前的状态
- mysql是通过undo log日志实现的（回滚日志），事务的所有修改操作都会写入到undo log中，**它是一个逻辑文件**，事务无法成功提交，系统会执行undo log中的撤销操作，达到事务回滚的目的
- 数据示例：`事务1将表t中id=10的记录a字段值从'old_value'改为'new_value'”`

> 持久性

- 事务处理结束后，对数据的修改就是永久的，即便系统故障也不会丢失
- mysql通过redo log来保证持久性的,事务的所有修改操作都会在redo log中生成一条记录，和undo log的区别在于，**redo log记录的是事务对数据库哪个数据页做了什么修改**，属于物理日志
- 数据示例：`修改页号5的偏移量20处的值为123"`

> 隔离性

数据库允许多个并发事务同时对其数据进行读写和修改的能力，每个事务是隔离开的不会互相影响

`为什么要有隔离性，首先要清楚并发事务会有什么问题` 

同时处理多个事务的时候会有下面几个问题：

- 脏读：一个事务读取到了另外一个事务未提交的修改过的数据
  - 事务A读取数据B，然后把B修改为100，此时事务C进来读取B，获得了100，然后事务A发现有问题，回滚数据，那么事务C读取的数据就是有问题的数据
- 不可重复读：一个事务里多次读取数据，读到的数据不一样
  - 事务A读取数据B，此时B是50，然后事务C读取B将其修改为100然后提交事务，事务A再次读取B，发现B是100了
- 幻读：一个事务内多次**查询某个符合查询条件的记录数量**，前后两次查到的记录数量不一致，就发生了幻读
  - 注意：这里只正对查询记录的条数

mysql提出了四种隔离级别来规避这些现象，隔离级别越高性能越低

- 读未提交  RN：一个事务还没提交，就可以被其他事务看到
  - 上面三种问题都会发生
- 读已提交：事务提交后，才能被其他事务看到
  - 解决脏读的问题
- 可重复读：指一个事务执行过程中看到的数据都是一致的
  - mysql的默认隔离级别，基于MVCC实现
  - 解决不可重读的问题，能够**部分**解决幻读的问题
- 串行化：会对记录加上读写锁，另外事务如果发生读写冲突，需要等前一个事务执行完成才能继续执行。
  - 不会有上述的问题



#### 3、简述乐观锁以及悲观锁的区别以及使用场景

乐观锁：

- 做事比较乐观，认为资源被修改的概率比较低，先修改共享资源，然后再提交的时候检查有没有发生冲突，如果资源被修改过，那么就放弃本次操作，也叫无锁编程
- 适合读多写少的场景
- 在线文档、git、SVN其实都是乐观锁的思想

悲观锁：

- 认为多线程同时修改共享资源的概率比较高，很容易出现冲突，所以访问共享资源前，就先上锁，保证其他线程无法修改资源
- 适用场景：写数据多的场景

#### 4、产生死锁的必要条件有哪些？如何解决死锁？

#### 5、Redis 如何实现分布式锁？

#### 6、简述 Redis 持久化中 RDB 以及 AOF 方案的优缺点

#### 7、简述 Redis 中如何防止缓存雪崩和缓存击穿、缓存穿透

> 缓存雪崩、缓存击穿

通常缓存数据都会设置一个过期时间，当大量缓存数据在同一时间失效或者Redis故障，此时大量用户请求会穿透redis直接访问数据库，导致数据库压力暴增甚至宕机，造成整个系统的崩溃，这就是缓存雪崩。

**大量数据同时过期导致**

- 如何防止:
  - 避免将大量的数据设置成同一个过期时间，比如设置过期时间时加上随机数。
  - 缓存不设置过期时间，后台线程定时更新缓存
  - 分布式锁
  - 多级缓存 设置不同的过期时间

redis故障

- 如何防止
  - 服务熔断或者限流
  - 构建redis缓存高可用集群

缓存击穿就是热点数据过期，大量请求穿过缓存了，可以理解成雪崩 的一个子集，防止方法可以参考上面的

- 加分布式锁
- 缓存永不过期

> 缓存穿透

指的是大量查询不存在的数据，这种数据缓存大概率不会有，查询就会达到数据库存

出现的可能：

- 业务误删数据
- 恶意攻击

预防措施

- 1、提前判断参数是否合理，恶意请求直接返回错误
- 2、缓存空值或某个默认值
- 3、使用布隆过滤器快速判断数据是否存在

#### 8、聚簇索引和非聚簇索引有什么区别？

9、Redis 有几种数据结构？Zset 是如何实现的？
10、简述脏读和幻读的发生场景，InnoDB 是如何解决幻读的？
为什么 Redis 在单线程下能如此快？
什么是数据库事务，MySQL 为什么会使用 InnoDB 作为默认选项
简述什么是最左匹配原则





```sql
select
   distinct cert.emp_id 
from
   cm_log cl 
inner join
   (
      select
         emp.id as emp_id,
         emp_cert.id as cert_id 
      from
         employee emp 
      left join
         emp_certificate emp_cert 
            on emp.id = emp_cert.emp_id 
      where
         emp.is_deleted=0
   ) cert 
      on (
         cl.ref_table='Employee' 
         and cl.ref_oid= cert.emp_id
      ) 
      or (
         cl.ref_table='EmpCertificate' 
         and cl.ref_oid= cert.cert_id
      ) 
where
   cl.last_upd_date >='2013-11-07 15:03:00' 
   and cl.last_upd_date<='2013-11-08 16:00:00';
```

